/*************************************************************************/
/*                                                                       */
/*               OCaml Migrate Parsetree transformed to Reason           */
/*                                                                       */
/*                         Frédéric Bour, Facebook                       */
/*            Jérémie Dimino and Leo White, Jane Street Europe           */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt           */
/*                         Alain Frisch, LexiFi                          */
/*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt        */
/*                                                                       */
/*   Copyright 2018 Institut National de Recherche en Informatique et    */
/*     en Automatique (INRIA).                                           */
/*                                                                       */
/*   All rights reserved.  This file is distributed under the terms of   */
/*   the GNU Lesser General Public License version 2.1, with the         */
/*   special exception on linking described in the file LICENSE.         */
/*                                                                       */
/*************************************************************************/

open Stdlib0;
open Ast_409_helper;

module Location = Location;
module Longident = Longident;

[@warning "-9"];

module Asttypes = {
  type constant /*IF_CURRENT = Asttypes.constant */ =
    | Const_int(int)
    | Const_char(char)
    | Const_string(string, option(string))
    | Const_float(string)
    | Const_int32(int32)
    | Const_int64(int64)
    | Const_nativeint(nativeint);

  type rec_flag /*IF_CURRENT = Asttypes.rec_flag */ =
    | Nonrecursive
    | Recursive;

  type direction_flag /*IF_CURRENT = Asttypes.direction_flag */ =
    | Upto
    | Downto;

  /* Order matters, used in polymorphic comparison */
  type private_flag /*IF_CURRENT = Asttypes.private_flag */ =
    | Private
    | Public;

  type mutable_flag /*IF_CURRENT = Asttypes.mutable_flag */ =
    | Immutable
    | Mutable;

  type virtual_flag /*IF_CURRENT = Asttypes.virtual_flag */ =
    | Virtual
    | Concrete;

  type override_flag /*IF_CURRENT = Asttypes.override_flag */ =
    | Override
    | Fresh;

  type closed_flag /*IF_CURRENT = Asttypes.closed_flag */ =
    | Closed
    | Open;

  type label = string;

  type arg_label /*IF_CURRENT = Asttypes.arg_label */ =
    | Nolabel
    | Labelled(string) /*  label:T -> ... */
    | Optional(string); /* ?label:T -> ... */

  type loc('a) =
    Location.loc('a) = {
      txt: 'a,
      loc: Location.t,
    };

  type variance /*IF_CURRENT = Asttypes.variance */ =
    | Covariant
    | Contravariant
    | Invariant;
};

module Parsetree = {
  open Asttypes;

  type constant /*IF_CURRENT = Parsetree.constant */ =
    | Pconst_integer(string, option(char))
    /* 3 3l 3L 3n

          Suffixes [g-z][G-Z] are accepted by the parser.
          Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
       */
    | Pconst_char(char)
    /* 'c' */
    | Pconst_string(string, option(string))
    /* "constant"
          {delim|other constant|delim}
       */
    | Pconst_float(string, option(char));
  /* 3.4 2e5 1.4e-4

        Suffixes [g-z][G-Z] are accepted by the parser.
        Suffixes are rejected by the typechecker.
     */

  type location_stack = list(Location.t);

  /** {1 Extension points} */;

  type attribute /*IF_CURRENT = Parsetree.attribute */ = {
    attr_name: loc(string),
    attr_payload: payload,
    attr_loc: Location.t,
  }
  /* [@id ARG]
        [@@id ARG]

        Metadata containers passed around within the AST.
        The compiler ignores unknown attributes.
     */
  and extension = (loc(string), payload)
  /* [%id ARG]
        [%%id ARG]

        Sub-language placeholder -- rejected by the typechecker.
     */
  and attributes = list(attribute)
  and payload /*IF_CURRENT = Parsetree.payload */ =
    | PStr(structure)
    | PSig(signature) /* : SIG */
    | PTyp(core_type) /* : T */
    | PPat(pattern, option(expression)) /* ? P  or  ? P when E */
  /** {1 Core language} */
  /* Type expressions */
  and core_type /*IF_CURRENT = Parsetree.core_type */ = {
    ptyp_desc: core_type_desc,
    ptyp_loc: Location.t,
    ptyp_loc_stack: location_stack,
    ptyp_attributes: attributes /* ... [@id1] [@id2] */
  }
  and core_type_desc /*IF_CURRENT = Parsetree.core_type_desc */ =
    | Ptyp_any
    /*  _ */
    | Ptyp_var(string)
    /* 'a */
    | Ptyp_arrow(arg_label, core_type, core_type)
    /* T1 -> T2       Simple
          ~l:T1 -> T2    Labelled
          ?l:T1 -> T2    Optional
       */
    | Ptyp_tuple(list(core_type))
    /* T1 * ... * Tn

          Invariant: n >= 2
       */
    | Ptyp_constr(loc(Longident.t), list(core_type))
    /* tconstr
          T tconstr
          (T1, ..., Tn) tconstr
       */
    | Ptyp_object(list(object_field), closed_flag)
    /* < l1:T1; ...; ln:Tn >     (flag = Closed)
          < l1:T1; ...; ln:Tn; .. > (flag = Open)
       */
    | Ptyp_class(loc(Longident.t), list(core_type))
    /* #tconstr
          T #tconstr
          (T1, ..., Tn) #tconstr
       */
    | Ptyp_alias(core_type, string)
    /* T as 'a */
    | Ptyp_variant(list(row_field), closed_flag, option(list(label)))
    /* [ `A|`B ]         (flag = Closed; labels = None)
          [> `A|`B ]        (flag = Open;   labels = None)
          [< `A|`B ]        (flag = Closed; labels = Some [])
          [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
       */
    | Ptyp_poly(list(loc(string)), core_type)
    /* 'a1 ... 'an. T

          Can only appear in the following context:

          - As the core_type of a Ppat_constraint node corresponding
            to a constraint on a let-binding: let x : 'a1 ... 'an. T
            = e ...

          - Under Cfk_virtual for methods (not values).

          - As the core_type of a Pctf_method node.

          - As the core_type of a Pexp_poly node.

          - As the pld_type field of a label_declaration.

          - As a core_type of a Ptyp_object node.
       */
    | Ptyp_package(package_type)
    /* (module S) */
    | Ptyp_extension(extension)
  /* [%id] */
  and package_type = (
    loc(Longident.t),
    list((loc(Longident.t), core_type)),
  )
  /*
    (module S)
    (module S with type t1 = T1 and ... and tn = Tn)
   */
  and row_field /*IF_CURRENT = Parsetree.row_field */ = {
    prf_desc: row_field_desc,
    prf_loc: Location.t,
    prf_attributes: attributes,
  }
  and row_field_desc /*IF_CURRENT = Parsetree.row_field_desc */ =
    | Rtag(loc(label), bool, list(core_type))
    /* [`A]                   ( true,  [] )
          [`A of T]              ( false, [T] )
          [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
          [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

          - The 'bool' field is true if the tag contains a
            constant (empty) constructor.
          - '&' occurs when several types are used for the same constructor
            (see 4.2 in the manual)
       */
    | Rinherit(core_type)
  /* [ T ] */
  and object_field /*IF_CURRENT = Parsetree.object_field */ = {
    pof_desc: object_field_desc,
    pof_loc: Location.t,
    pof_attributes: attributes,
  }
  and object_field_desc /*IF_CURRENT = Parsetree.object_field_desc */ =
    | Otag(loc(label), core_type)
    | Oinherit(core_type)
  /* Patterns */
  and pattern /*IF_CURRENT = Parsetree.pattern */ = {
    ppat_desc: pattern_desc,
    ppat_loc: Location.t,
    ppat_loc_stack: location_stack,
    ppat_attributes: attributes /* ... [@id1] [@id2] */
  }
  and pattern_desc /*IF_CURRENT = Parsetree.pattern_desc */ =
    | Ppat_any
    /* _ */
    | Ppat_var(loc(string))
    /* x */
    | Ppat_alias(pattern, loc(string))
    /* P as 'a */
    | Ppat_constant(constant)
    /* 1, 'a', "true", 1.0, 1l, 1L, 1n */
    | Ppat_interval(constant, constant)
    /* 'a'..'z'

       Other forms of interval are recognized by the parser
       but rejected by the type-checker. */
    | Ppat_tuple(list(pattern))
    /* (P1, ..., Pn)

          Invariant: n >= 2
       */
    | Ppat_construct(loc(Longident.t), option(pattern))
    /* C                None
          C P              Some P
          C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
       */
    | Ppat_variant(label, option(pattern))
    /* `A             (None)
          `A P           (Some P)
       */
    | Ppat_record(list((loc(Longident.t), pattern)), closed_flag)
    /* { l1=P1; ...; ln=Pn }     (flag = Closed)
          { l1=P1; ...; ln=Pn; _}   (flag = Open)

          Invariant: n > 0
       */
    | Ppat_array(list(pattern))
    /* [| P1; ...; Pn |] */
    | Ppat_or(pattern, pattern)
    /* P1 | P2 */
    | Ppat_constraint(pattern, core_type)
    /* (P : T) */
    | Ppat_type(loc(Longident.t))
    /* #tconst */
    | Ppat_lazy(pattern)
    /* lazy P */
    | Ppat_unpack(loc(option(string)))
    /* (module P)        Some "P"
          (module _)        None

          Note: (module P : S) is represented as
          Ppat_constraint(Ppat_unpack, Ptyp_package)
       */
    | Ppat_exception(pattern)
    /* exception P */
    | Ppat_extension(extension)
    /* [%id] */
    | Ppat_open(loc(Longident.t), pattern)
  /* M.(P) */
  /* Value expressions */
  and expression /*IF_CURRENT = Parsetree.expression */ = {
    pexp_desc: expression_desc,
    pexp_loc: Location.t,
    pexp_loc_stack: location_stack,
    pexp_attributes: attributes /* ... [@id1] [@id2] */
  }
  and expression_desc /*IF_CURRENT = Parsetree.expression_desc */ =
    | Pexp_ident(loc(Longident.t))
    /* x
          M.x
       */
    | Pexp_constant(constant)
    /* 1, 'a', "true", 1.0, 1l, 1L, 1n */
    | Pexp_let(rec_flag, list(value_binding), expression)
    /* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
          let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
       */
    | Pexp_function(list(case))
    /* function P1 -> E1 | ... | Pn -> En */
    | Pexp_fun(arg_label, option(expression), pattern, expression)
    /* fun P -> E1                          (Simple, None)
          fun ~l:P -> E1                       (Labelled l, None)
          fun ?l:P -> E1                       (Optional l, None)
          fun ?l:(P = E0) -> E1                (Optional l, Some E0)

          Notes:
          - If E0 is provided, only Optional is allowed.
          - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
          - "let f P = E" is represented using Pexp_fun.
       */
    | Pexp_apply(expression, list((arg_label, expression)))
    /* E0 ~l1:E1 ... ~ln:En
          li can be empty (non labeled argument) or start with '?'
          (optional argument).

          Invariant: n > 0
       */
    | Pexp_match(expression, list(case))
    /* match E0 with P1 -> E1 | ... | Pn -> En */
    | Pexp_try(expression, list(case))
    /* try E0 with P1 -> E1 | ... | Pn -> En */
    | Pexp_tuple(list(expression))
    /* (E1, ..., En)

          Invariant: n >= 2
       */
    | Pexp_construct(loc(Longident.t), option(expression))
    /* C                None
          C E              Some E
          C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
       */
    | Pexp_variant(label, option(expression))
    /* `A             (None)
          `A E           (Some E)
       */
    | Pexp_record(
        list((loc(Longident.t), expression)),
        option(expression),
      )
    /* { l1=P1; ...; ln=Pn }     (None)
          { E0 with l1=P1; ...; ln=Pn }   (Some E0)

          Invariant: n > 0
       */
    | Pexp_field(expression, loc(Longident.t))
    /* E.l */
    | Pexp_setfield(expression, loc(Longident.t), expression)
    /* E1.l <- E2 */
    | Pexp_array(list(expression))
    /* [| E1; ...; En |] */
    | Pexp_ifthenelse(expression, expression, option(expression))
    /* if E1 then E2 else E3 */
    | Pexp_sequence(expression, expression)
    /* E1; E2 */
    | Pexp_while(expression, expression)
    /* while E1 do E2 done */
    | Pexp_for(pattern, expression, expression, direction_flag, expression)
    /* for i = E1 to E2 do E3 done      (flag = Upto)
          for i = E1 downto E2 do E3 done  (flag = Downto)
       */
    | Pexp_constraint(expression, core_type)
    /* (E : T) */
    | Pexp_coerce(expression, option(core_type), core_type)
    /* (E :> T)        (None, T)
          (E : T0 :> T)   (Some T0, T)
       */
    | Pexp_send(expression, loc(label))
    /*  E # m */
    | Pexp_new(loc(Longident.t))
    /* new M.c */
    | Pexp_setinstvar(loc(label), expression)
    /* x <- 2 */
    | Pexp_override(list((loc(label), expression)))
    /* {< x1 = E1; ...; Xn = En >} */
    | Pexp_letmodule(loc(option(string)), module_expr, expression)
    /* let module M = ME in E */
    | Pexp_letexception(extension_constructor, expression)
    /* let exception C in E */
    | Pexp_assert(expression)
    /* assert E
       Note: "assert false" is treated in a special way by the
       type-checker. */
    | Pexp_lazy(expression)
    /* lazy E */
    | Pexp_poly(expression, option(core_type))
    /* Used for method bodies.

       Can only be used as the expression under Cfk_concrete
       for methods (not values). */
    | Pexp_object(class_structure)
    /* object ... end */
    | Pexp_newtype(loc(string), expression)
    /* fun (type t) -> E */
    | Pexp_pack(module_expr)
    /* (module ME)

       (module ME : S) is represented as
       Pexp_constraint(Pexp_pack, Ptyp_package S) */
    | Pexp_open(open_declaration, expression)
    /* M.(E)
       let open M in E
       let! open M in E */
    | Pexp_letop(letop)
    /* let* P = E in E
       let* P = E and* P = E in E */
    | Pexp_extension(extension)
    /* [%id] */
    | Pexp_unreachable
  /* . */
  and case /*IF_CURRENT = Parsetree.case */ = {
    /* (P -> E) or (P when E0 -> E) */
    pc_lhs: pattern,
    pc_guard: option(expression),
    pc_rhs: expression,
  }
  and letop /*IF_CURRENT = Parsetree.letop */ = {
    let_: binding_op,
    ands: list(binding_op),
    body: expression,
  }
  and binding_op /*IF_CURRENT = Parsetree.binding_op */ = {
    pbop_op: loc(string),
    pbop_pat: pattern,
    pbop_exp: expression,
    pbop_loc: Location.t,
  }
  /* Value descriptions */
  and value_description /*IF_CURRENT = Parsetree.value_description */ = {
    pval_name: loc(string),
    pval_type: core_type,
    pval_prim: list(string),
    pval_attributes: attributes, /* ... [@@id1] [@@id2] */
    pval_loc: Location.t,
  }
  /*
     val x: T                            (prim = [])
     external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
   */
  /* Type declarations */
  and type_declaration /*IF_CURRENT = Parsetree.type_declaration */ = {
    ptype_name: loc(string),
    ptype_params: list((core_type, variance)),
    /* ('a1,...'an) t; None represents  _*/
    ptype_cstrs: list((core_type, core_type, Location.t)),
    /* ... constraint T1=T1'  ... constraint Tn=Tn' */
    ptype_kind: type_kind,
    ptype_private: private_flag, /* = private ... */
    ptype_manifest: option(core_type), /* = T */
    ptype_attributes: attributes, /* ... [@@id1] [@@id2] */
    ptype_loc: Location.t,
  }
  /*
     type t                     (abstract, no manifest)
     type t = T0                (abstract, manifest=T0)
     type t = C of T | ...      (variant,  no manifest)
     type t = T0 = C of T | ... (variant,  manifest=T0)
     type t = {l: T; ...}       (record,   no manifest)
     type t = T0 = {l : T; ...} (record,   manifest=T0)
     type t = ..                (open,     no manifest)
   */
  and type_kind /*IF_CURRENT = Parsetree.type_kind */ =
    | Ptype_abstract
    | Ptype_variant(list(constructor_declaration))
    | Ptype_record(list(label_declaration))
    /* Invariant: non-empty list */
    | Ptype_open
  and label_declaration /*IF_CURRENT = Parsetree.label_declaration */ = {
    pld_name: loc(string),
    pld_mutable: mutable_flag,
    pld_type: core_type,
    pld_loc: Location.t,
    pld_attributes: attributes /* l : T [@id1] [@id2] */
  }
  /*  { ...; l: T; ... }            (mutable=Immutable)
          { ...; mutable l: T; ... }    (mutable=Mutable)

          Note: T can be a Ptyp_poly.
      */
  and constructor_declaration /*IF_CURRENT = Parsetree.constructor_declaration */ = {
    pcd_name: loc(string),
    pcd_args: constructor_arguments,
    pcd_res: option(core_type),
    pcd_loc: Location.t,
    pcd_attributes: attributes /* C of ... [@id1] [@id2] */
  }
  and constructor_arguments /*IF_CURRENT = Parsetree.constructor_arguments */ =
    | Pcstr_tuple(list(core_type))
    | Pcstr_record(list(label_declaration))
  /*
     | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
     | C: T0                  (res = Some T0, args = [])
     | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
     | C of {...}             (res = None,    args = Pcstr_record)
     | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
     | C of {...} as t        (res = None,    args = Pcstr_record)
   */
  and type_extension /*IF_CURRENT = Parsetree.type_extension */ = {
    ptyext_path: loc(Longident.t),
    ptyext_params: list((core_type, variance)),
    ptyext_constructors: list(extension_constructor),
    ptyext_private: private_flag,
    ptyext_loc: Location.t,
    ptyext_attributes: attributes /* ... [@@id1] [@@id2] */
  }
  /*
     type t += ...
   */
  and extension_constructor /*IF_CURRENT = Parsetree.extension_constructor */ = {
    pext_name: loc(string),
    pext_kind: extension_constructor_kind,
    pext_loc: Location.t,
    pext_attributes: attributes /* C of ... [@id1] [@id2] */
  }
  /* exception E */
  and type_exception /*IF_CURRENT = Parsetree.type_exception */ = {
    ptyexn_constructor: extension_constructor,
    ptyexn_loc: Location.t,
    ptyexn_attributes: attributes /* ... [@@id1] [@@id2] */
  }
  and extension_constructor_kind /*IF_CURRENT = Parsetree.extension_constructor_kind */ =
    | Pext_decl(constructor_arguments, option(core_type))
    /*
       | C of T1 * ... * Tn     ([T1; ...; Tn], None)
       | C: T0                  ([], Some T0)
       | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
     */
    | Pext_rebind(loc(Longident.t))
  /*
     | C = D
   */
  /** {1 Class language} */
  /* Type expressions for the class language */
  and class_type /*IF_CURRENT = Parsetree.class_type */ = {
    pcty_desc: class_type_desc,
    pcty_loc: Location.t,
    pcty_attributes: attributes /* ... [@id1] [@id2] */
  }
  and class_type_desc /*IF_CURRENT = Parsetree.class_type_desc */ =
    | Pcty_constr(loc(Longident.t), list(core_type))
    /* c
       ['a1, ..., 'an] c */
    | Pcty_signature(class_signature)
    /* object ... end */
    | Pcty_arrow(arg_label, core_type, class_type)
    /* T -> CT       Simple
          ~l:T -> CT    Labelled l
          ?l:T -> CT    Optional l
       */
    | Pcty_extension(extension)
    /* [%id] */
    | Pcty_open(open_description, class_type)
  /* let open M in CT */
  and class_signature /*IF_CURRENT = Parsetree.class_signature */ = {
    pcsig_self: core_type,
    pcsig_fields: list(class_type_field),
  }
  /* object('selfpat) ... end
        object ... end             (self = Ptyp_any)
     */
  and class_type_field /*IF_CURRENT = Parsetree.class_type_field */ = {
    pctf_desc: class_type_field_desc,
    pctf_loc: Location.t,
    pctf_attributes: attributes /* ... [@@id1] [@@id2] */
  }
  and class_type_field_desc /*IF_CURRENT = Parsetree.class_type_field_desc */ =
    | Pctf_inherit(class_type)
    /* inherit CT */
    | Pctf_val((loc(label), mutable_flag, virtual_flag, core_type))
    /* val x: T */
    | Pctf_method((loc(label), private_flag, virtual_flag, core_type))
    /* method x: T

          Note: T can be a Ptyp_poly.
       */
    | Pctf_constraint((core_type, core_type))
    /* constraint T1 = T2 */
    | Pctf_attribute(attribute)
    /* [@@@id] */
    | Pctf_extension(extension)
  /* [%%id] */
  and class_infos /*IF_CURRENT = 'a Parsetree.class_infos */('a) = {
    pci_virt: virtual_flag,
    pci_params: list((core_type, variance)),
    pci_name: loc(string),
    pci_expr: 'a,
    pci_loc: Location.t,
    pci_attributes: attributes /* ... [@@id1] [@@id2] */
  }
  /* class c = ...
        class ['a1,...,'an] c = ...
        class virtual c = ...

        Also used for "class type" declaration.
     */
  and class_description = class_infos(class_type)
  and class_type_declaration = class_infos(class_type)
  /* Value expressions for the class language */
  and class_expr /*IF_CURRENT = Parsetree.class_expr */ = {
    pcl_desc: class_expr_desc,
    pcl_loc: Location.t,
    pcl_attributes: attributes /* ... [@id1] [@id2] */
  }
  and class_expr_desc /*IF_CURRENT = Parsetree.class_expr_desc */ =
    | Pcl_constr(loc(Longident.t), list(core_type))
    /* c
       ['a1, ..., 'an] c */
    | Pcl_structure(class_structure)
    /* object ... end */
    | Pcl_fun(arg_label, option(expression), pattern, class_expr)
    /* fun P -> CE                          (Simple, None)
          fun ~l:P -> CE                       (Labelled l, None)
          fun ?l:P -> CE                       (Optional l, None)
          fun ?l:(P = E0) -> CE                (Optional l, Some E0)
       */
    | Pcl_apply(class_expr, list((arg_label, expression)))
    /* CE ~l1:E1 ... ~ln:En
          li can be empty (non labeled argument) or start with '?'
          (optional argument).

          Invariant: n > 0
       */
    | Pcl_let(rec_flag, list(value_binding), class_expr)
    /* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
          let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
       */
    | Pcl_constraint(class_expr, class_type)
    /* (CE : CT) */
    | Pcl_extension(extension)
    /* [%id] */
    | Pcl_open(open_description, class_expr)
  /* let open M in CE */
  and class_structure /*IF_CURRENT = Parsetree.class_structure */ = {
    pcstr_self: pattern,
    pcstr_fields: list(class_field),
  }
  /* object(selfpat) ... end
        object ... end           (self = Ppat_any)
     */
  and class_field /*IF_CURRENT = Parsetree.class_field */ = {
    pcf_desc: class_field_desc,
    pcf_loc: Location.t,
    pcf_attributes: attributes /* ... [@@id1] [@@id2] */
  }
  and class_field_desc /*IF_CURRENT = Parsetree.class_field_desc */ =
    | Pcf_inherit(override_flag, class_expr, option(loc(string)))
    /* inherit CE
          inherit CE as x
          inherit! CE
          inherit! CE as x
       */
    | Pcf_val((loc(label), mutable_flag, class_field_kind))
    /* val x = E
          val virtual x: T
       */
    | Pcf_method((loc(label), private_flag, class_field_kind))
    /* method x = E            (E can be a Pexp_poly)
          method virtual x: T     (T can be a Ptyp_poly)
       */
    | Pcf_constraint((core_type, core_type))
    /* constraint T1 = T2 */
    | Pcf_initializer(expression)
    /* initializer E */
    | Pcf_attribute(attribute)
    /* [@@@id] */
    | Pcf_extension(extension)
  /* [%%id] */
  and class_field_kind /*IF_CURRENT = Parsetree.class_field_kind */ =
    | Cfk_virtual(core_type)
    | Cfk_concrete(override_flag, expression)
  and class_declaration = class_infos(class_expr)
  /** {1 Module language} */
  /* Type expressions for the module language */
  and module_type /*IF_CURRENT = Parsetree.module_type */ = {
    pmty_desc: module_type_desc,
    pmty_loc: Location.t,
    pmty_attributes: attributes /* ... [@id1] [@id2] */
  }
  and module_type_desc /*IF_CURRENT = Parsetree.module_type_desc */ =
    | Pmty_ident(loc(Longident.t))
    /* S */
    | Pmty_signature(signature)
    /* sig ... end */
    | Pmty_functor(functor_parameter, module_type)
    /* functor(X : MT1) -> MT2 */
    | Pmty_with(module_type, list(with_constraint))
    /* MT with ... */
    | Pmty_typeof(module_expr)
    /* module type of ME */
    | Pmty_extension(extension)
    /* [%id] */
    | Pmty_alias(loc(Longident.t))
  /* (module M) */
  and functor_parameter /*IF_CURRENT = Parsetree.functor_parameter */ =
    | Unit
    /* () */
    | Named(loc(option(string)), module_type)
  /* (X : MT)          Some X, MT
     (_ : MT)          None, MT */
  and signature = list(signature_item)
  and signature_item /*IF_CURRENT = Parsetree.signature_item */ = {
    psig_desc: signature_item_desc,
    psig_loc: Location.t,
  }
  and signature_item_desc /*IF_CURRENT = Parsetree.signature_item_desc */ =
    | Psig_value(value_description)
    /*
      val x: T
      external x: T = "s1" ... "sn"
     */
    | Psig_type(rec_flag, list(type_declaration))
    /* type t1 = ... and ... and tn  = ... */
    | Psig_typesubst(list(type_declaration))
    /* type t1 := ... and ... and tn := ...  */
    | Psig_typext(type_extension)
    /* type t1 += ... */
    | Psig_exception(type_exception)
    /* exception C of T */
    | Psig_module(module_declaration)
    /* module X = M
       module X : MT */
    | Psig_modsubst(module_substitution)
    /* module X := M */
    | Psig_recmodule(list(module_declaration))
    /* module rec X1 : MT1 and ... and Xn : MTn */
    | Psig_modtype(module_type_declaration)
    /* module type S = MT
       module type S */
    | Psig_open(open_description)
    /* open X */
    | Psig_include(include_description)
    /* include MT */
    | Psig_class(list(class_description))
    /* class c1 : ... and ... and cn : ... */
    | Psig_class_type(list(class_type_declaration))
    /* class type ct1 = ... and ... and ctn = ... */
    | Psig_attribute(attribute)
    /* [@@@id] */
    | Psig_extension(extension, attributes)
  /* [%%id] */
  and module_declaration /*IF_CURRENT = Parsetree.module_declaration */ = {
    pmd_name: loc(option(string)),
    pmd_type: module_type,
    pmd_attributes: attributes, /* ... [@@id1] [@@id2] */
    pmd_loc: Location.t,
  }
  /* S : MT */
  and module_substitution /*IF_CURRENT = Parsetree.module_substitution */ = {
    pms_name: loc(string),
    pms_manifest: loc(Longident.t),
    pms_attributes: attributes, /* ... [@@id1] [@@id2] */
    pms_loc: Location.t,
  }
  and module_type_declaration /*IF_CURRENT = Parsetree.module_type_declaration */ = {
    pmtd_name: loc(string),
    pmtd_type: option(module_type),
    pmtd_attributes: attributes, /* ... [@@id1] [@@id2] */
    pmtd_loc: Location.t,
  }
  /* S = MT
        S       (abstract module type declaration, pmtd_type = None)
     */
  and open_infos /*IF_CURRENT = 'a Parsetree.open_infos */('a) = {
    popen_expr: 'a,
    popen_override: override_flag,
    popen_loc: Location.t,
    popen_attributes: attributes,
  }
  /* open! X - popen_override = Override (silences the 'used identifier
                                   shadowing' warning)
        open  X - popen_override = Fresh
     */
  and open_description = open_infos(loc(Longident.t))
  /* open M.N
     open M(N).O */
  and open_declaration = open_infos(module_expr)
  /* open M.N
     open M(N).O
     open struct ... end */
  and include_infos /*IF_CURRENT = 'a Parsetree.include_infos */('a) = {
    pincl_mod: 'a,
    pincl_loc: Location.t,
    pincl_attributes: attributes,
  }
  and include_description = include_infos(module_type)
  /* include MT */
  and include_declaration = include_infos(module_expr)
  /* include ME */
  and with_constraint /*IF_CURRENT = Parsetree.with_constraint */ =
    | Pwith_type(loc(Longident.t), type_declaration)
    /* with type X.t = ...

       Note: the last component of the longident must match
       the name of the type_declaration. */
    | Pwith_module(loc(Longident.t), loc(Longident.t))
    /* with module X.Y = Z */
    | Pwith_typesubst(loc(Longident.t), type_declaration)
    /* with type X.t := ..., same format as [Pwith_type] */
    | Pwith_modsubst(loc(Longident.t), loc(Longident.t))
  /* with module X.Y := Z */
  /* Value expressions for the module language */
  and module_expr /*IF_CURRENT = Parsetree.module_expr */ = {
    pmod_desc: module_expr_desc,
    pmod_loc: Location.t,
    pmod_attributes: attributes /* ... [@id1] [@id2] */
  }
  and module_expr_desc /*IF_CURRENT = Parsetree.module_expr_desc */ =
    | Pmod_ident(loc(Longident.t))
    /* X */
    | Pmod_structure(structure)
    /* struct ... end */
    | Pmod_functor(functor_parameter, module_expr)
    /* functor(X : MT1) -> ME */
    | Pmod_apply(module_expr, module_expr)
    /* ME1(ME2) */
    | Pmod_constraint(module_expr, module_type)
    /* (ME : MT) */
    | Pmod_unpack(expression)
    /* (val E) */
    | Pmod_extension(extension)
  /* [%id] */
  and structure = list(structure_item)
  and structure_item /*IF_CURRENT = Parsetree.structure_item */ = {
    pstr_desc: structure_item_desc,
    pstr_loc: Location.t,
  }
  and structure_item_desc /*IF_CURRENT = Parsetree.structure_item_desc */ =
    | Pstr_eval(expression, attributes)
    /* E */
    | Pstr_value(rec_flag, list(value_binding))
    /* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
          let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
       */
    | Pstr_primitive(value_description)
    /*  val x: T
        external x: T = "s1" ... "sn" */
    | Pstr_type(rec_flag, list(type_declaration))
    /* type t1 = ... and ... and tn = ... */
    | Pstr_typext(type_extension)
    /* type t1 += ... */
    | Pstr_exception(type_exception)
    /* exception C of T
       exception C = M.X */
    | Pstr_module(module_binding)
    /* module X = ME */
    | Pstr_recmodule(list(module_binding))
    /* module rec X1 = ME1 and ... and Xn = MEn */
    | Pstr_modtype(module_type_declaration)
    /* module type S = MT */
    | Pstr_open(open_declaration)
    /* open X */
    | Pstr_class(list(class_declaration))
    /* class c1 = ... and ... and cn = ... */
    | Pstr_class_type(list(class_type_declaration))
    /* class type ct1 = ... and ... and ctn = ... */
    | Pstr_include(include_declaration)
    /* include ME */
    | Pstr_attribute(attribute)
    /* [@@@id] */
    | Pstr_extension(extension, attributes)
  /* [%%id] */
  and value_binding /*IF_CURRENT = Parsetree.value_binding */ = {
    pvb_pat: pattern,
    pvb_expr: expression,
    pvb_attributes: attributes,
    pvb_loc: Location.t,
  }
  and module_binding /*IF_CURRENT = Parsetree.module_binding */ = {
    pmb_name: loc(option(string)),
    pmb_expr: module_expr,
    pmb_attributes: attributes,
    pmb_loc: Location.t,
  };
  /* X = ME */

  /** {1 Toplevel} */;

  /* Toplevel phrases */

  type toplevel_phrase /*IF_CURRENT = Parsetree.toplevel_phrase */ =
    | Ptop_def(structure)
    | Ptop_dir(toplevel_directive)
  /* #use, #load ... */
  and toplevel_directive /*IF_CURRENT = Parsetree.toplevel_directive */ = {
    pdir_name: loc(string),
    pdir_arg: option(directive_argument),
    pdir_loc: Location.t,
  }
  and directive_argument /*IF_CURRENT = Parsetree.directive_argument */ = {
    pdira_desc: directive_argument_desc,
    pdira_loc: Location.t,
  }
  and directive_argument_desc /*IF_CURRENT = Parsetree.directive_argument_desc */ =
    | Pdir_string(string)
    | Pdir_int(string, option(char))
    | Pdir_ident(Longident.t)
    | Pdir_bool(bool);
};

module Docstrings: {
  /** (Re)Initialise all docstring state */

  let init: unit => unit;

  /** Emit warnings for unattached and ambiguous docstrings */

  let warn_bad_docstrings: unit => unit;

  /** {2 Docstrings} */;

  /** Documentation comments */

  type docstring;

  /** Create a docstring */

  let docstring: (string, Location.t) => docstring;

  /** Register a docstring */

  let register: docstring => unit;

  /** Get the text of a docstring */

  let docstring_body: docstring => string;

  /** Get the location of a docstring */

  let docstring_loc: docstring => Location.t;

  /** {2 Set functions}

      These functions are used by the lexer to associate docstrings to
      the locations of tokens. */;

  /** Docstrings immediately preceding a token */

  let set_pre_docstrings: (Lexing.position, list(docstring)) => unit;

  /** Docstrings immediately following a token */

  let set_post_docstrings: (Lexing.position, list(docstring)) => unit;

  /** Docstrings not immediately adjacent to a token */

  let set_floating_docstrings: (Lexing.position, list(docstring)) => unit;

  /** Docstrings immediately following the token which precedes this one */

  let set_pre_extra_docstrings: (Lexing.position, list(docstring)) => unit;

  /** Docstrings immediately preceding the token which follows this one */

  let set_post_extra_docstrings: (Lexing.position, list(docstring)) => unit;

  /** {2 Items}

      The {!docs} type represents documentation attached to an item. */;

  type docs = {
    docs_pre: option(docstring),
    docs_post: option(docstring),
  };

  let empty_docs: docs;

  let docs_attr: docstring => Parsetree.attribute;

  /** Convert item documentation to attributes and add them to an
      attribute list */

  let add_docs_attrs: (docs, Parsetree.attributes) => Parsetree.attributes;

  /** Fetch the item documentation for the current symbol. This also
      marks this documentation (for ambiguity warnings). */

  let symbol_docs: unit => docs;
  let symbol_docs_lazy: unit => Lazy.t(docs);

  /** Fetch the item documentation for the symbols between two
      positions. This also marks this documentation (for ambiguity
      warnings). */

  let rhs_docs: (int, int) => docs;
  let rhs_docs_lazy: (int, int) => Lazy.t(docs);

  /** Mark the item documentation for the current symbol (for ambiguity
      warnings). */

  let mark_symbol_docs: unit => unit;

  /** Mark as associated the item documentation for the symbols between
      two positions (for ambiguity warnings) */

  let mark_rhs_docs: (int, int) => unit;

  /** {2 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. */;

  type info = option(docstring);

  let empty_info: info;

  let info_attr: docstring => Parsetree.attribute;

  /** Convert field info to attributes and add them to an
      attribute list */

  let add_info_attrs: (info, Parsetree.attributes) => Parsetree.attributes;

  /** Fetch the field info for the current symbol. */

  let symbol_info: unit => info;

  /** Fetch the field info following the symbol at a given position. */

  let rhs_info: int => info;

  /** {2 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. */;

  type text = list(docstring);

  let empty_text: text;
  let empty_text_lazy: Lazy.t(text);

  let text_attr: docstring => Parsetree.attribute;

  /** Convert text to attributes and add them to an attribute list */

  let add_text_attrs: (text, Parsetree.attributes) => Parsetree.attributes;

  /** Fetch the text preceding the current symbol. */

  let symbol_text: unit => text;
  let symbol_text_lazy: unit => Lazy.t(text);

  /** Fetch the text preceding the symbol at the given position. */

  let rhs_text: int => text;
  let rhs_text_lazy: int => Lazy.t(text);

  /** {2 Extra text}

      There may be additional text attached to the delimiters of a block
      (e.g. [struct] and [end]). This is fetched by the following
      functions, which are applied to the contents of the block rather
      than the delimiters. */;

  /** Fetch additional text preceding the current symbol */

  let symbol_pre_extra_text: unit => text;

  /** Fetch additional text following the current symbol */

  let symbol_post_extra_text: unit => text;

  /** Fetch additional text preceding the symbol at the given position */

  let rhs_pre_extra_text: int => text;

  /** Fetch additional text following the symbol at the given position */

  let rhs_post_extra_text: int => text;

  /** Fetch text following the symbol at the given position */

  let rhs_post_text: int => text;

  module WithMenhir: {
    /** Fetch the item documentation for the current symbol. This also
        marks this documentation (for ambiguity warnings). */

    let symbol_docs: ((Lexing.position, Lexing.position)) => docs;
    let symbol_docs_lazy:
      ((Lexing.position, Lexing.position)) => Lazy.t(docs);

    /** Fetch the item documentation for the symbols between two
        positions. This also marks this documentation (for ambiguity
        warnings). */

    let rhs_docs: (Lexing.position, Lexing.position) => docs;
    let rhs_docs_lazy: (Lexing.position, Lexing.position) => Lazy.t(docs);

    /** Mark the item documentation for the current symbol (for ambiguity
        warnings). */

    let mark_symbol_docs: ((Lexing.position, Lexing.position)) => unit;

    /** Mark as associated the item documentation for the symbols between
        two positions (for ambiguity warnings) */

    let mark_rhs_docs: (Lexing.position, Lexing.position) => unit;

    /** Fetch the field info for the current symbol. */

    let symbol_info: Lexing.position => info;

    /** Fetch the field info following the symbol at a given position. */

    let rhs_info: Lexing.position => info;

    /** Fetch the text preceding the current symbol. */

    let symbol_text: Lexing.position => text;
    let symbol_text_lazy: Lexing.position => Lazy.t(text);

    /** Fetch the text preceding the symbol at the given position. */

    let rhs_text: Lexing.position => text;
    let rhs_text_lazy: Lexing.position => Lazy.t(text);

    /** {3 Extra text}

        There may be additional text attached to the delimiters of a block
        (e.g. [struct] and [end]). This is fetched by the following
        functions, which are applied to the contents of the block rather
        than the delimiters. */;

    /** Fetch additional text preceding the current symbol */

    let symbol_pre_extra_text: Lexing.position => text;

    /** Fetch additional text following the current symbol */

    let symbol_post_extra_text: Lexing.position => text;

    /** Fetch additional text preceding the symbol at the given position */

    let rhs_pre_extra_text: Lexing.position => text;

    /** Fetch additional text following the symbol at the given position */

    let rhs_post_extra_text: Lexing.position => text;

    /** Fetch text following the symbol at the given position */

    let rhs_post_text: Lexing.position => text;
  };
} = {
  open Location;

  /* Docstrings */

  /* A docstring is "attached" if it has been inserted in the AST. This
     is used for generating unexpected docstring warnings. */
  type ds_attached =
    | Unattached /* Not yet attached anything.*/
    | Info /* Attached to a field or constructor. */
    | Docs; /* Attached to an item or as floating text. */

  /* A docstring is "associated" with an item if there are no blank lines between
     them. This is used for generating docstring ambiguity warnings. */
  type ds_associated =
    | Zero /* Not associated with an item */
    | One /* Associated with one item */
    | Many; /* Associated with multiple items (ambiguity) */

  type docstring = {
    ds_body: string,
    ds_loc: Location.t,
    mutable ds_attached,
    mutable ds_associated,
  };

  /* List of docstrings */

  let docstrings: ref(list(docstring)) = ref([]);

  /* Warn for unused and ambiguous docstrings */

  let warn_bad_docstrings = () =>
    if (Warnings.is_active(Warnings.Bad_docstring(true))) {
      List.iter(
        ds =>
          switch (ds.ds_attached) {
          | Info => ()
          | Unattached =>
            prerr_warning(ds.ds_loc, Warnings.Bad_docstring(true))
          | Docs =>
            switch (ds.ds_associated) {
            | Zero
            | One => ()
            | Many => prerr_warning(ds.ds_loc, Warnings.Bad_docstring(false))
            }
          },
        List.rev(docstrings^),
      );
    };

  /* Docstring constructors and destructors */

  let docstring = (body, loc) => {
    let ds = {
      ds_body: body,
      ds_loc: loc,
      ds_attached: Unattached,
      ds_associated: Zero,
    };

    ds;
  };

  let register = ds => docstrings := [ds, ...docstrings^];

  let docstring_body = ds => ds.ds_body;

  let docstring_loc = ds => ds.ds_loc;

  /* Docstrings attached to items */

  type docs = {
    docs_pre: option(docstring),
    docs_post: option(docstring),
  };

  let empty_docs = {docs_pre: None, docs_post: None};

  let doc_loc = {txt: "ocaml.doc", loc: Location.none};

  let docs_attr = ds => {
    open Parsetree;
    let exp = {
      pexp_desc:
        Pexp_constant([@implicit_arity] Pconst_string(ds.ds_body, None)),
      pexp_loc: ds.ds_loc,
      pexp_loc_stack: [],
      pexp_attributes: [],
    };

    let item = {
      pstr_desc: [@implicit_arity] Pstr_eval(exp, []),
      pstr_loc: exp.pexp_loc,
    };

    {
      attr_name: doc_loc,
      attr_payload: PStr([item]),
      attr_loc: Location.none,
    };
  };

  let add_docs_attrs = (docs, attrs) => {
    let attrs =
      switch (docs.docs_pre) {
      | None
      | Some({ds_body: "", _}) => attrs
      | Some(ds) => [docs_attr(ds), ...attrs]
      };

    let attrs =
      switch (docs.docs_post) {
      | None
      | Some({ds_body: "", _}) => attrs
      | Some(ds) => attrs @ [docs_attr(ds)]
      };

    attrs;
  };

  /* Docstrings attached to constructors or fields */

  type info = option(docstring);

  let empty_info = None;

  let info_attr = docs_attr;

  let add_info_attrs = (info, attrs) =>
    switch (info) {
    | None
    | Some({ds_body: "", _}) => attrs
    | Some(ds) => attrs @ [info_attr(ds)]
    };

  /* Docstrings not attached to a specific item */

  type text = list(docstring);

  let empty_text = [];
  let empty_text_lazy = lazy([]);

  let text_loc = {txt: "ocaml.text", loc: Location.none};

  let text_attr = ds => {
    open Parsetree;
    let exp = {
      pexp_desc:
        Pexp_constant([@implicit_arity] Pconst_string(ds.ds_body, None)),
      pexp_loc: ds.ds_loc,
      pexp_loc_stack: [],
      pexp_attributes: [],
    };

    let item = {
      pstr_desc: [@implicit_arity] Pstr_eval(exp, []),
      pstr_loc: exp.pexp_loc,
    };

    {
      attr_name: text_loc,
      attr_payload: PStr([item]),
      attr_loc: Location.none,
    };
  };

  let add_text_attrs = (dsl, attrs) => {
    let fdsl =
      List.filter(
        fun
        | {ds_body: ""} => false
        | _ => true,
        dsl,
      );
    List.map(text_attr, fdsl) @ attrs;
  };

  /* Find the first non-info docstring in a list, attach it and return it */
  let get_docstring = (~info, dsl) => {
    let rec loop =
      fun
      | [] => None
      | [{ds_attached: Info, _}, ...rest] => loop(rest)
      | [ds, ..._] => {
          ds.ds_attached = (if (info) {Info} else {Docs});
          Some(ds);
        };

    loop(dsl);
  };

  /* Find all the non-info docstrings in a list, attach them and return them */
  let get_docstrings = dsl => {
    let rec loop = acc =>
      fun
      | [] => List.rev(acc)
      | [{ds_attached: Info, _}, ...rest] => loop(acc, rest)
      | [ds, ...rest] => {
          ds.ds_attached = Docs;
          loop([ds, ...acc], rest);
        };

    loop([], dsl);
  };

  /* "Associate" all the docstrings in a list */
  let associate_docstrings = dsl =>
    List.iter(
      ds =>
        switch (ds.ds_associated) {
        | Zero => ds.ds_associated = One
        | One
        | Many => ds.ds_associated = Many
        },
      dsl,
    );

  /* Map from positions to pre docstrings */

  let pre_table: Hashtbl.t(Lexing.position, list(docstring)) =
    Hashtbl.create(50);

  let set_pre_docstrings = (pos, dsl) =>
    if (dsl != []) {
      Hashtbl.add(pre_table, pos, dsl);
    };

  let get_pre_docs = pos =>
    try({
      let dsl = Hashtbl.find(pre_table, pos);
      associate_docstrings(dsl);
      get_docstring(~info=false, dsl);
    }) {
    | Not_found => None
    };

  let mark_pre_docs = pos =>
    try({
      let dsl = Hashtbl.find(pre_table, pos);
      associate_docstrings(dsl);
    }) {
    | Not_found => ()
    };

  /* Map from positions to post docstrings */

  let post_table: Hashtbl.t(Lexing.position, list(docstring)) =
    Hashtbl.create(50);

  let set_post_docstrings = (pos, dsl) =>
    if (dsl != []) {
      Hashtbl.add(post_table, pos, dsl);
    };

  let get_post_docs = pos =>
    try({
      let dsl = Hashtbl.find(post_table, pos);
      associate_docstrings(dsl);
      get_docstring(~info=false, dsl);
    }) {
    | Not_found => None
    };

  let mark_post_docs = pos =>
    try({
      let dsl = Hashtbl.find(post_table, pos);
      associate_docstrings(dsl);
    }) {
    | Not_found => ()
    };

  let get_info = pos =>
    try({
      let dsl = Hashtbl.find(post_table, pos);
      get_docstring(~info=true, dsl);
    }) {
    | Not_found => None
    };

  /* Map from positions to floating docstrings */

  let floating_table: Hashtbl.t(Lexing.position, list(docstring)) =
    Hashtbl.create(50);

  let set_floating_docstrings = (pos, dsl) =>
    if (dsl != []) {
      Hashtbl.add(floating_table, pos, dsl);
    };

  let get_text = pos =>
    try({
      let dsl = Hashtbl.find(floating_table, pos);
      get_docstrings(dsl);
    }) {
    | Not_found => []
    };

  let get_post_text = pos =>
    try({
      let dsl = Hashtbl.find(post_table, pos);
      get_docstrings(dsl);
    }) {
    | Not_found => []
    };

  /* Maps from positions to extra docstrings */

  let pre_extra_table: Hashtbl.t(Lexing.position, list(docstring)) =
    Hashtbl.create(50);

  let set_pre_extra_docstrings = (pos, dsl) =>
    if (dsl != []) {
      Hashtbl.add(pre_extra_table, pos, dsl);
    };

  let get_pre_extra_text = pos =>
    try({
      let dsl = Hashtbl.find(pre_extra_table, pos);
      get_docstrings(dsl);
    }) {
    | Not_found => []
    };

  let post_extra_table: Hashtbl.t(Lexing.position, list(docstring)) =
    Hashtbl.create(50);

  let set_post_extra_docstrings = (pos, dsl) =>
    if (dsl != []) {
      Hashtbl.add(post_extra_table, pos, dsl);
    };

  let get_post_extra_text = pos =>
    try({
      let dsl = Hashtbl.find(post_extra_table, pos);
      get_docstrings(dsl);
    }) {
    | Not_found => []
    };

  /* Docstrings from parser actions */
  module WithParsing = {
    let symbol_docs = () => {
      docs_pre: get_pre_docs(Parsing.symbol_start_pos()),
      docs_post: get_post_docs(Parsing.symbol_end_pos()),
    };

    let symbol_docs_lazy = () => {
      let p1 = Parsing.symbol_start_pos();
      let p2 = Parsing.symbol_end_pos();
      lazy({docs_pre: get_pre_docs(p1), docs_post: get_post_docs(p2)});
    };

    let rhs_docs = (pos1, pos2) => {
      docs_pre: get_pre_docs(Parsing.rhs_start_pos(pos1)),
      docs_post: get_post_docs(Parsing.rhs_end_pos(pos2)),
    };

    let rhs_docs_lazy = (pos1, pos2) => {
      let p1 = Parsing.rhs_start_pos(pos1);
      let p2 = Parsing.rhs_end_pos(pos2);
      lazy({docs_pre: get_pre_docs(p1), docs_post: get_post_docs(p2)});
    };

    let mark_symbol_docs = () => {
      mark_pre_docs(Parsing.symbol_start_pos());
      mark_post_docs(Parsing.symbol_end_pos());
    };

    let mark_rhs_docs = (pos1, pos2) => {
      mark_pre_docs(Parsing.rhs_start_pos(pos1));
      mark_post_docs(Parsing.rhs_end_pos(pos2));
    };

    let symbol_info = () => get_info(Parsing.symbol_end_pos());

    let rhs_info = pos => get_info(Parsing.rhs_end_pos(pos));

    let symbol_text = () => get_text(Parsing.symbol_start_pos());

    let symbol_text_lazy = () => {
      let pos = Parsing.symbol_start_pos();
      lazy(get_text(pos));
    };

    let rhs_text = pos => get_text(Parsing.rhs_start_pos(pos));

    let rhs_post_text = pos => get_post_text(Parsing.rhs_end_pos(pos));

    let rhs_text_lazy = pos => {
      let pos = Parsing.rhs_start_pos(pos);
      lazy(get_text(pos));
    };

    let symbol_pre_extra_text = () =>
      get_pre_extra_text(Parsing.symbol_start_pos());

    let symbol_post_extra_text = () =>
      get_post_extra_text(Parsing.symbol_end_pos());

    let rhs_pre_extra_text = pos =>
      get_pre_extra_text(Parsing.rhs_start_pos(pos));

    let rhs_post_extra_text = pos =>
      get_post_extra_text(Parsing.rhs_end_pos(pos));
  };

  include WithParsing;

  module WithMenhir = {
    let symbol_docs = ((startpos, endpos)) => {
      docs_pre: get_pre_docs(startpos),
      docs_post: get_post_docs(endpos),
    };

    let symbol_docs_lazy = ((p1, p2)) =>
      lazy({docs_pre: get_pre_docs(p1), docs_post: get_post_docs(p2)});

    let rhs_docs = (pos1, pos2) => {
      docs_pre: get_pre_docs(pos1),
      docs_post: get_post_docs(pos2),
    };

    let rhs_docs_lazy = (p1, p2) =>
      lazy({docs_pre: get_pre_docs(p1), docs_post: get_post_docs(p2)});

    let mark_symbol_docs = ((startpos, endpos)) => {
      mark_pre_docs(startpos);
      mark_post_docs(endpos);
      ();
    };

    let mark_rhs_docs = (pos1, pos2) => {
      mark_pre_docs(pos1);
      mark_post_docs(pos2);
      ();
    };

    let symbol_info = endpos => get_info(endpos);

    let rhs_info = endpos => get_info(endpos);

    let symbol_text = startpos => get_text(startpos);

    let symbol_text_lazy = startpos => lazy(get_text(startpos));

    let rhs_text = pos => get_text(pos);

    let rhs_post_text = pos => get_post_text(pos);

    let rhs_text_lazy = pos => lazy(get_text(pos));

    let symbol_pre_extra_text = startpos => get_pre_extra_text(startpos);

    let symbol_post_extra_text = endpos => get_post_extra_text(endpos);

    let rhs_pre_extra_text = pos => get_pre_extra_text(pos);

    let rhs_post_extra_text = pos => get_post_extra_text(pos);
  };

  /* (Re)Initialise all comment state */

  let init = () => {
    docstrings := [];
    Hashtbl.reset(pre_table);
    Hashtbl.reset(post_table);
    Hashtbl.reset(floating_table);
    Hashtbl.reset(pre_extra_table);
    Hashtbl.reset(post_extra_table);
  };
};

module Ast_helper: {
  open Asttypes;
  open Docstrings;
  open Parsetree;

  type with_loc('a) = Location.loc('a);
  type loc = Location.t;

  type lid = with_loc(Longident.t);
  type str = with_loc(string);
  type str_opt = with_loc(option(string));
  type attrs = list(attribute);

  /** {1 Default locations} */;

  /** Default value for all optional location arguments. */

  let default_loc: ref(loc);

  /** Set the [default_loc] within the scope of the execution
      of the provided function. */

  let with_default_loc: (loc, unit => 'a) => 'a;

  /** {1 Constants} */;

  module Const: {
    let char: char => constant;
    let string: (~quotation_delimiter: string=?, string) => constant;
    let integer: (~suffix: char=?, string) => constant;
    let int: (~suffix: char=?, int) => constant;
    let int32: (~suffix: char=?, int32) => constant;
    let int64: (~suffix: char=?, int64) => constant;
    let nativeint: (~suffix: char=?, nativeint) => constant;
    let float: (~suffix: char=?, string) => constant;
  };

  /** {1 Attributes} */

  module Attr: {let mk: (~loc: loc=?, str, payload) => attribute;};

  /** {1 Core language} */;

  /** Type expressions */

  module Typ: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, core_type_desc) => core_type;
    let attr: (core_type, attribute) => core_type;

    let any: (~loc: loc=?, ~attrs: attrs=?, unit) => core_type;
    let var: (~loc: loc=?, ~attrs: attrs=?, string) => core_type;
    let arrow:
      (~loc: loc=?, ~attrs: attrs=?, arg_label, core_type, core_type) =>
      core_type;
    let tuple: (~loc: loc=?, ~attrs: attrs=?, list(core_type)) => core_type;
    let constr:
      (~loc: loc=?, ~attrs: attrs=?, lid, list(core_type)) => core_type;
    let object_:
      (~loc: loc=?, ~attrs: attrs=?, list(object_field), closed_flag) =>
      core_type;
    let class_:
      (~loc: loc=?, ~attrs: attrs=?, lid, list(core_type)) => core_type;
    let alias: (~loc: loc=?, ~attrs: attrs=?, core_type, string) => core_type;
    let variant:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        list(row_field),
        closed_flag,
        option(list(label))
      ) =>
      core_type;
    let poly:
      (~loc: loc=?, ~attrs: attrs=?, list(str), core_type) => core_type;
    let package:
      (~loc: loc=?, ~attrs: attrs=?, lid, list((lid, core_type))) =>
      core_type;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => core_type;

    let force_poly: core_type => core_type;

    /** [varify_constructors newtypes te] is type expression [te], of which
        any of nullary type constructor [tc] is replaced by type variable of
        the same name, if [tc]'s name appears in [newtypes].
        Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]
        appears in [newtypes].
        @since 4.05
    */

    let varify_constructors: (list(str), core_type) => core_type;
  };

  /** Patterns */

  module Pat: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, pattern_desc) => pattern;
    let attr: (pattern, attribute) => pattern;

    let any: (~loc: loc=?, ~attrs: attrs=?, unit) => pattern;
    let var: (~loc: loc=?, ~attrs: attrs=?, str) => pattern;
    let alias: (~loc: loc=?, ~attrs: attrs=?, pattern, str) => pattern;
    let constant: (~loc: loc=?, ~attrs: attrs=?, constant) => pattern;
    let interval:
      (~loc: loc=?, ~attrs: attrs=?, constant, constant) => pattern;
    let tuple: (~loc: loc=?, ~attrs: attrs=?, list(pattern)) => pattern;
    let construct:
      (~loc: loc=?, ~attrs: attrs=?, lid, option(pattern)) => pattern;
    let variant:
      (~loc: loc=?, ~attrs: attrs=?, label, option(pattern)) => pattern;
    let record:
      (~loc: loc=?, ~attrs: attrs=?, list((lid, pattern)), closed_flag) =>
      pattern;
    let array: (~loc: loc=?, ~attrs: attrs=?, list(pattern)) => pattern;
    let or_: (~loc: loc=?, ~attrs: attrs=?, pattern, pattern) => pattern;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, pattern, core_type) => pattern;
    let type_: (~loc: loc=?, ~attrs: attrs=?, lid) => pattern;
    let lazy_: (~loc: loc=?, ~attrs: attrs=?, pattern) => pattern;
    let unpack: (~loc: loc=?, ~attrs: attrs=?, str_opt) => pattern;
    let open_: (~loc: loc=?, ~attrs: attrs=?, lid, pattern) => pattern;
    let exception_: (~loc: loc=?, ~attrs: attrs=?, pattern) => pattern;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => pattern;
  };

  /** Expressions */

  module Exp: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, expression_desc) => expression;
    let attr: (expression, attribute) => expression;

    let ident: (~loc: loc=?, ~attrs: attrs=?, lid) => expression;
    let constant: (~loc: loc=?, ~attrs: attrs=?, constant) => expression;
    let let_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        rec_flag,
        list(value_binding),
        expression
      ) =>
      expression;
    let fun_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        arg_label,
        option(expression),
        pattern,
        expression
      ) =>
      expression;
    let function_: (~loc: loc=?, ~attrs: attrs=?, list(case)) => expression;
    let apply:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        expression,
        list((arg_label, expression))
      ) =>
      expression;
    let match:
      (~loc: loc=?, ~attrs: attrs=?, expression, list(case)) => expression;
    let try_:
      (~loc: loc=?, ~attrs: attrs=?, expression, list(case)) => expression;
    let tuple: (~loc: loc=?, ~attrs: attrs=?, list(expression)) => expression;
    let construct:
      (~loc: loc=?, ~attrs: attrs=?, lid, option(expression)) => expression;
    let variant:
      (~loc: loc=?, ~attrs: attrs=?, label, option(expression)) => expression;
    let record:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        list((lid, expression)),
        option(expression)
      ) =>
      expression;
    let field: (~loc: loc=?, ~attrs: attrs=?, expression, lid) => expression;
    let setfield:
      (~loc: loc=?, ~attrs: attrs=?, expression, lid, expression) => expression;
    let array: (~loc: loc=?, ~attrs: attrs=?, list(expression)) => expression;
    let ifthenelse:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        expression,
        expression,
        option(expression)
      ) =>
      expression;
    let sequence:
      (~loc: loc=?, ~attrs: attrs=?, expression, expression) => expression;
    let while_:
      (~loc: loc=?, ~attrs: attrs=?, expression, expression) => expression;
    let for_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        pattern,
        expression,
        expression,
        direction_flag,
        expression
      ) =>
      expression;
    let coerce:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        expression,
        option(core_type),
        core_type
      ) =>
      expression;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, expression, core_type) => expression;
    let send: (~loc: loc=?, ~attrs: attrs=?, expression, str) => expression;
    let new_: (~loc: loc=?, ~attrs: attrs=?, lid) => expression;
    let setinstvar:
      (~loc: loc=?, ~attrs: attrs=?, str, expression) => expression;
    let override:
      (~loc: loc=?, ~attrs: attrs=?, list((str, expression))) => expression;
    let letmodule:
      (~loc: loc=?, ~attrs: attrs=?, str_opt, module_expr, expression) =>
      expression;
    let letexception:
      (~loc: loc=?, ~attrs: attrs=?, extension_constructor, expression) =>
      expression;
    let assert_: (~loc: loc=?, ~attrs: attrs=?, expression) => expression;
    let lazy_: (~loc: loc=?, ~attrs: attrs=?, expression) => expression;
    let poly:
      (~loc: loc=?, ~attrs: attrs=?, expression, option(core_type)) =>
      expression;
    let object_: (~loc: loc=?, ~attrs: attrs=?, class_structure) => expression;
    let newtype: (~loc: loc=?, ~attrs: attrs=?, str, expression) => expression;
    let pack: (~loc: loc=?, ~attrs: attrs=?, module_expr) => expression;
    let open_:
      (~loc: loc=?, ~attrs: attrs=?, open_declaration, expression) =>
      expression;
    let letop:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        binding_op,
        list(binding_op),
        expression
      ) =>
      expression;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => expression;
    let unreachable: (~loc: loc=?, ~attrs: attrs=?, unit) => expression;

    let case: (pattern, ~guard: expression=?, expression) => case;
    let binding_op: (str, pattern, expression, loc) => binding_op;
  };

  /** Value declarations */

  module Val: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~prim: list(string)=?,
        str,
        core_type
      ) =>
      value_description;
  };

  /** Type declarations */

  module Type: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        ~params: list((core_type, variance))=?,
        ~cstrs: list((core_type, core_type, loc))=?,
        ~kind: type_kind=?,
        ~priv: private_flag=?,
        ~manifest: core_type=?,
        str
      ) =>
      type_declaration;

    let constructor:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~info: info=?,
        ~args: constructor_arguments=?,
        ~res: core_type=?,
        str
      ) =>
      constructor_declaration;
    let field:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~info: info=?,
        ~mut: mutable_flag=?,
        str,
        core_type
      ) =>
      label_declaration;
  };

  /** Type extensions */

  module Te: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~params: list((core_type, variance))=?,
        ~priv: private_flag=?,
        lid,
        list(extension_constructor)
      ) =>
      type_extension;

    let mk_exception:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, extension_constructor) =>
      type_exception;

    let constructor:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~info: info=?,
        str,
        extension_constructor_kind
      ) =>
      extension_constructor;

    let decl:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~info: info=?,
        ~args: constructor_arguments=?,
        ~res: core_type=?,
        str
      ) =>
      extension_constructor;
    let rebind:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, ~info: info=?, str, lid) =>
      extension_constructor;
  };

  /** {1 Module language} */;

  /** Module type expressions */

  module Mty: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, module_type_desc) => module_type;
    let attr: (module_type, attribute) => module_type;

    let ident: (~loc: loc=?, ~attrs: attrs=?, lid) => module_type;
    let alias: (~loc: loc=?, ~attrs: attrs=?, lid) => module_type;
    let signature: (~loc: loc=?, ~attrs: attrs=?, signature) => module_type;
    let functor_:
      (~loc: loc=?, ~attrs: attrs=?, functor_parameter, module_type) =>
      module_type;
    let with_:
      (~loc: loc=?, ~attrs: attrs=?, module_type, list(with_constraint)) =>
      module_type;
    let typeof_: (~loc: loc=?, ~attrs: attrs=?, module_expr) => module_type;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => module_type;
  };

  /** Module expressions */

  module Mod: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, module_expr_desc) => module_expr;
    let attr: (module_expr, attribute) => module_expr;

    let ident: (~loc: loc=?, ~attrs: attrs=?, lid) => module_expr;
    let structure: (~loc: loc=?, ~attrs: attrs=?, structure) => module_expr;
    let functor_:
      (~loc: loc=?, ~attrs: attrs=?, functor_parameter, module_expr) =>
      module_expr;
    let apply:
      (~loc: loc=?, ~attrs: attrs=?, module_expr, module_expr) => module_expr;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, module_expr, module_type) => module_expr;
    let unpack: (~loc: loc=?, ~attrs: attrs=?, expression) => module_expr;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => module_expr;
  };

  /** Signature items */

  module Sig: {
    let mk: (~loc: loc=?, signature_item_desc) => signature_item;

    let value: (~loc: loc=?, value_description) => signature_item;
    let type_:
      (~loc: loc=?, rec_flag, list(type_declaration)) => signature_item;
    let type_subst: (~loc: loc=?, list(type_declaration)) => signature_item;
    let type_extension: (~loc: loc=?, type_extension) => signature_item;
    let exception_: (~loc: loc=?, type_exception) => signature_item;
    let module_: (~loc: loc=?, module_declaration) => signature_item;
    let mod_subst: (~loc: loc=?, module_substitution) => signature_item;
    let rec_module: (~loc: loc=?, list(module_declaration)) => signature_item;
    let modtype: (~loc: loc=?, module_type_declaration) => signature_item;
    let open_: (~loc: loc=?, open_description) => signature_item;
    let include_: (~loc: loc=?, include_description) => signature_item;
    let class_: (~loc: loc=?, list(class_description)) => signature_item;
    let class_type:
      (~loc: loc=?, list(class_type_declaration)) => signature_item;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => signature_item;
    let attribute: (~loc: loc=?, attribute) => signature_item;
    let text: text => list(signature_item);
  };

  /** Structure items */

  module Str: {
    let mk: (~loc: loc=?, structure_item_desc) => structure_item;

    let eval:
      (~loc: loc=?, ~attrs: attributes=?, expression) => structure_item;
    let value: (~loc: loc=?, rec_flag, list(value_binding)) => structure_item;
    let primitive: (~loc: loc=?, value_description) => structure_item;
    let type_:
      (~loc: loc=?, rec_flag, list(type_declaration)) => structure_item;
    let type_extension: (~loc: loc=?, type_extension) => structure_item;
    let exception_: (~loc: loc=?, type_exception) => structure_item;
    let module_: (~loc: loc=?, module_binding) => structure_item;
    let rec_module: (~loc: loc=?, list(module_binding)) => structure_item;
    let modtype: (~loc: loc=?, module_type_declaration) => structure_item;
    let open_: (~loc: loc=?, open_declaration) => structure_item;
    let class_: (~loc: loc=?, list(class_declaration)) => structure_item;
    let class_type:
      (~loc: loc=?, list(class_type_declaration)) => structure_item;
    let include_: (~loc: loc=?, include_declaration) => structure_item;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => structure_item;
    let attribute: (~loc: loc=?, attribute) => structure_item;
    let text: text => list(structure_item);
  };

  /** Module declarations */

  module Md: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        str_opt,
        module_type
      ) =>
      module_declaration;
  };

  /** Module substitutions */

  module Ms: {
    let mk:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, ~text: text=?, str, lid) =>
      module_substitution;
  };

  /** Module type declarations */

  module Mtd: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        ~typ: module_type=?,
        str
      ) =>
      module_type_declaration;
  };

  /** Module bindings */

  module Mb: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        str_opt,
        module_expr
      ) =>
      module_binding;
  };

  /** Opens */

  module Opn: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~override: override_flag=?,
        'a
      ) =>
      open_infos('a);
  };

  /** Includes */

  module Incl: {
    let mk:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, 'a) => include_infos('a);
  };

  /** Value bindings */

  module Vb: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        pattern,
        expression
      ) =>
      value_binding;
  };

  /** {1 Class language} */;

  /** Class type expressions */

  module Cty: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, class_type_desc) => class_type;
    let attr: (class_type, attribute) => class_type;

    let constr:
      (~loc: loc=?, ~attrs: attrs=?, lid, list(core_type)) => class_type;
    let signature:
      (~loc: loc=?, ~attrs: attrs=?, class_signature) => class_type;
    let arrow:
      (~loc: loc=?, ~attrs: attrs=?, arg_label, core_type, class_type) =>
      class_type;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => class_type;
    let open_:
      (~loc: loc=?, ~attrs: attrs=?, open_description, class_type) =>
      class_type;
  };

  /** Class type fields */

  module Ctf: {
    let mk:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, class_type_field_desc) =>
      class_type_field;
    let attr: (class_type_field, attribute) => class_type_field;

    let inherit_:
      (~loc: loc=?, ~attrs: attrs=?, class_type) => class_type_field;
    let val_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        str,
        mutable_flag,
        virtual_flag,
        core_type
      ) =>
      class_type_field;
    let method:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        str,
        private_flag,
        virtual_flag,
        core_type
      ) =>
      class_type_field;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, core_type, core_type) => class_type_field;
    let extension:
      (~loc: loc=?, ~attrs: attrs=?, extension) => class_type_field;
    let attribute: (~loc: loc=?, attribute) => class_type_field;
    let text: text => list(class_type_field);
  };

  /** Class expressions */

  module Cl: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, class_expr_desc) => class_expr;
    let attr: (class_expr, attribute) => class_expr;

    let constr:
      (~loc: loc=?, ~attrs: attrs=?, lid, list(core_type)) => class_expr;
    let structure:
      (~loc: loc=?, ~attrs: attrs=?, class_structure) => class_expr;
    let fun_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        arg_label,
        option(expression),
        pattern,
        class_expr
      ) =>
      class_expr;
    let apply:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        class_expr,
        list((arg_label, expression))
      ) =>
      class_expr;
    let let_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        rec_flag,
        list(value_binding),
        class_expr
      ) =>
      class_expr;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, class_expr, class_type) => class_expr;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => class_expr;
    let open_:
      (~loc: loc=?, ~attrs: attrs=?, open_description, class_expr) =>
      class_expr;
  };

  /** Class fields */

  module Cf: {
    let mk:
      (~loc: loc=?, ~attrs: attrs=?, ~docs: docs=?, class_field_desc) =>
      class_field;
    let attr: (class_field, attribute) => class_field;

    let inherit_:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        override_flag,
        class_expr,
        option(str)
      ) =>
      class_field;
    let val_:
      (~loc: loc=?, ~attrs: attrs=?, str, mutable_flag, class_field_kind) =>
      class_field;
    let method:
      (~loc: loc=?, ~attrs: attrs=?, str, private_flag, class_field_kind) =>
      class_field;
    let constraint_:
      (~loc: loc=?, ~attrs: attrs=?, core_type, core_type) => class_field;
    let initializer_:
      (~loc: loc=?, ~attrs: attrs=?, expression) => class_field;
    let extension: (~loc: loc=?, ~attrs: attrs=?, extension) => class_field;
    let attribute: (~loc: loc=?, attribute) => class_field;
    let text: text => list(class_field);

    let virtual_: core_type => class_field_kind;
    let concrete: (override_flag, expression) => class_field_kind;
  };

  /** Classes */

  module Ci: {
    let mk:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        ~docs: docs=?,
        ~text: text=?,
        ~virt: virtual_flag=?,
        ~params: list((core_type, variance))=?,
        str,
        'a
      ) =>
      class_infos('a);
  };

  /** Class signatures */

  module Csig: {
    let mk: (core_type, list(class_type_field)) => class_signature;
  };

  /** Class structures */

  module Cstr: {let mk: (pattern, list(class_field)) => class_structure;};

  /** Row fields */

  module Rf: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, row_field_desc) => row_field;
    let tag:
      (
        ~loc: loc=?,
        ~attrs: attrs=?,
        with_loc(label),
        bool,
        list(core_type)
      ) =>
      row_field;
    let inherit_: (~loc: loc=?, core_type) => row_field;
  };

  /** Object fields */

  module Of: {
    let mk: (~loc: loc=?, ~attrs: attrs=?, object_field_desc) => object_field;
    let tag:
      (~loc: loc=?, ~attrs: attrs=?, with_loc(label), core_type) =>
      object_field;
    let inherit_: (~loc: loc=?, core_type) => object_field;
  };
} = {
  open Asttypes;
  open Parsetree;
  open Docstrings;

  type with_loc('a) = Location.loc('a);
  type loc = Location.t;

  type lid = with_loc(Longident.t);
  type str = with_loc(string);
  type str_opt = with_loc(option(string));
  type attrs = list(attribute);

  let default_loc = ref(Location.none);

  let with_default_loc = (l, f) =>
    Misc.protect_refs([[@implicit_arity] Misc.R(default_loc, l)], f);

  module Const = {
    let integer = (~suffix=?, i) =>
      [@implicit_arity] Pconst_integer(i, suffix);
    let int = (~suffix=?, i) => integer(~suffix?, Int.to_string(i));
    let int32 = (~suffix='l', i) => integer(~suffix, Int32.to_string(i));
    let int64 = (~suffix='L', i) => integer(~suffix, Int64.to_string(i));
    let nativeint = (~suffix='n', i) =>
      integer(~suffix, Nativeint.to_string(i));
    let float = (~suffix=?, f) => [@implicit_arity] Pconst_float(f, suffix);
    let char = c => Pconst_char(c);
    let string = (~quotation_delimiter=?, s) =>
      [@implicit_arity] Pconst_string(s, quotation_delimiter);
  };

  module Attr = {
    let mk = (~loc=default_loc^, name, payload) => {
      attr_name: name,
      attr_payload: payload,
      attr_loc: loc,
    };
  };

  module Typ = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      ptyp_desc: d,
      ptyp_loc: loc,
      ptyp_loc_stack: [],
      ptyp_attributes: attrs,
    };

    let attr = (d, a) => {...d, ptyp_attributes: d.ptyp_attributes @ [a]};

    let any = (~loc=?, ~attrs=?, ()) => mk(~loc?, ~attrs?, Ptyp_any);
    let var = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ptyp_var(a));
    let arrow = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_arrow(a, b, c));
    let tuple = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ptyp_tuple(a));
    let constr = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_constr(a, b));
    let object_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_object(a, b));
    let class_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_class(a, b));
    let alias = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_alias(a, b));
    let variant = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_variant(a, b, c));
    let poly = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_poly(a, b));
    let package = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ptyp_package(a, b));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Ptyp_extension(a));

    let force_poly = t =>
      switch (t.ptyp_desc) {
      | Ptyp_poly(_) => t
      | _ => poly(~loc=t.ptyp_loc, [], t)
      }; /* -> ghost? */

    let varify_constructors = (var_names, t) => {
      let check_variable = (vl, loc, v) =>
        if (List.mem(v, vl)) {
          raise(
            Syntaxerr.(Error([@implicit_arity] Variable_in_scope(loc, v))),
          );
        };
      let var_names = List.map(v => v.txt, var_names);
      let rec loop = t => {
        let desc =
          switch (t.ptyp_desc) {
          | Ptyp_any => Ptyp_any
          | Ptyp_var(x) =>
            check_variable(var_names, t.ptyp_loc, x);
            Ptyp_var(x);
          | [@implicit_arity] Ptyp_arrow(label, core_type, core_type') =>
            [@implicit_arity]
            Ptyp_arrow(label, loop(core_type), loop(core_type'))
          | Ptyp_tuple(lst) => Ptyp_tuple(List.map(loop, lst))
          | [@implicit_arity] Ptyp_constr({txt: Longident.Lident(s)}, [])
              when List.mem(s, var_names) =>
            Ptyp_var(s)
          | [@implicit_arity] Ptyp_constr(longident, lst) =>
            [@implicit_arity] Ptyp_constr(longident, List.map(loop, lst))
          | [@implicit_arity] Ptyp_object(lst, o) =>
            [@implicit_arity]
            Ptyp_object(List.map(loop_object_field, lst), o)
          | [@implicit_arity] Ptyp_class(longident, lst) =>
            [@implicit_arity] Ptyp_class(longident, List.map(loop, lst))
          | [@implicit_arity] Ptyp_alias(core_type, string) =>
            check_variable(var_names, t.ptyp_loc, string);
            [@implicit_arity] Ptyp_alias(loop(core_type), string);
          | [@implicit_arity]
            Ptyp_variant(row_field_list, flag, lbl_lst_option) =>
            [@implicit_arity]
            Ptyp_variant(
              List.map(loop_row_field, row_field_list),
              flag,
              lbl_lst_option,
            )
          | [@implicit_arity] Ptyp_poly(string_lst, core_type) =>
            List.iter(
              v => check_variable(var_names, t.ptyp_loc, v.txt),
              string_lst,
            );
            [@implicit_arity] Ptyp_poly(string_lst, loop(core_type));
          | [@implicit_arity] Ptyp_package(longident, lst) =>
            [@implicit_arity]
            Ptyp_package(
              longident,
              List.map(((n, typ)) => (n, loop(typ)), lst),
            )
          | [@implicit_arity] Ptyp_extension(s, arg) =>
            [@implicit_arity] Ptyp_extension(s, arg)
          };

        {...t, ptyp_desc: desc};
      }
      and loop_row_field = field => {
        let prf_desc =
          switch (field.prf_desc) {
          | [@implicit_arity] Rtag(label, flag, lst) =>
            [@implicit_arity] Rtag(label, flag, List.map(loop, lst))
          | Rinherit(t) => Rinherit(loop(t))
          };

        {...field, prf_desc};
      }
      and loop_object_field = field => {
        let pof_desc =
          switch (field.pof_desc) {
          | [@implicit_arity] Otag(label, t) =>
            [@implicit_arity] Otag(label, loop(t))
          | Oinherit(t) => Oinherit(loop(t))
          };

        {...field, pof_desc};
      };

      loop(t);
    };
  };

  module Pat = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      ppat_desc: d,
      ppat_loc: loc,
      ppat_loc_stack: [],
      ppat_attributes: attrs,
    };
    let attr = (d, a) => {...d, ppat_attributes: d.ppat_attributes @ [a]};

    let any = (~loc=?, ~attrs=?, ()) => mk(~loc?, ~attrs?, Ppat_any);
    let var = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ppat_var(a));
    let alias = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_alias(a, b));
    let constant = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Ppat_constant(a));
    let interval = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_interval(a, b));
    let tuple = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ppat_tuple(a));
    let construct = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_construct(a, b));
    let variant = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_variant(a, b));
    let record = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_record(a, b));
    let array = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ppat_array(a));
    let or_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_or(a, b));
    let constraint_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_constraint(a, b));
    let type_ = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ppat_type(a));
    let lazy_ = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Ppat_lazy(a));
    let unpack = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Ppat_unpack(a));
    let open_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Ppat_open(a, b));
    let exception_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Ppat_exception(a));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Ppat_extension(a));
  };

  module Exp = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      pexp_desc: d,
      pexp_loc: loc,
      pexp_loc_stack: [],
      pexp_attributes: attrs,
    };
    let attr = (d, a) => {...d, pexp_attributes: d.pexp_attributes @ [a]};

    let ident = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_ident(a));
    let constant = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_constant(a));
    let let_ = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_let(a, b, c));
    let fun_ = (~loc=?, ~attrs=?, a, b, c, d) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_fun(a, b, c, d));
    let function_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_function(a));
    let apply = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_apply(a, b));
    let match = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_match(a, b));
    let try_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_try(a, b));
    let tuple = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_tuple(a));
    let construct = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_construct(a, b));
    let variant = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_variant(a, b));
    let record = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_record(a, b));
    let field = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_field(a, b));
    let setfield = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_setfield(a, b, c));
    let array = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_array(a));
    let ifthenelse = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_ifthenelse(a, b, c));
    let sequence = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_sequence(a, b));
    let while_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_while(a, b));
    let for_ = (~loc=?, ~attrs=?, a, b, c, d, e) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_for(a, b, c, d, e));
    let constraint_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_constraint(a, b));
    let coerce = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_coerce(a, b, c));
    let send = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_send(a, b));
    let new_ = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_new(a));
    let setinstvar = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_setinstvar(a, b));
    let override = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_override(a));
    let letmodule = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_letmodule(a, b, c));
    let letexception = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_letexception(a, b));
    let assert_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_assert(a));
    let lazy_ = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_lazy(a));
    let poly = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_poly(a, b));
    let object_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_object(a));
    let newtype = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_newtype(a, b));
    let pack = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pexp_pack(a));
    let open_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pexp_open(a, b));
    let letop = (~loc=?, ~attrs=?, let_, ands, body) =>
      mk(~loc?, ~attrs?, Pexp_letop({let_, ands, body}));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pexp_extension(a));
    let unreachable = (~loc=?, ~attrs=?, ()) =>
      mk(~loc?, ~attrs?, Pexp_unreachable);

    let case = (lhs, ~guard=?, rhs) => {
      pc_lhs: lhs,
      pc_guard: guard,
      pc_rhs: rhs,
    };

    let binding_op = (op, pat, exp, loc) => {
      pbop_op: op,
      pbop_pat: pat,
      pbop_exp: exp,
      pbop_loc: loc,
    };
  };

  module Mty = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      pmty_desc: d,
      pmty_loc: loc,
      pmty_attributes: attrs,
    };
    let attr = (d, a) => {...d, pmty_attributes: d.pmty_attributes @ [a]};

    let ident = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pmty_ident(a));
    let alias = (~loc=?, ~attrs=?, a) => mk(~loc?, ~attrs?, Pmty_alias(a));
    let signature = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pmty_signature(a));
    let functor_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pmty_functor(a, b));
    let with_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pmty_with(a, b));
    let typeof_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pmty_typeof(a));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pmty_extension(a));
  };

  module Mod = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      pmod_desc: d,
      pmod_loc: loc,
      pmod_attributes: attrs,
    };
    let attr = (d, a) => {...d, pmod_attributes: d.pmod_attributes @ [a]};

    let ident = (~loc=?, ~attrs=?, x) => mk(~loc?, ~attrs?, Pmod_ident(x));
    let structure = (~loc=?, ~attrs=?, x) =>
      mk(~loc?, ~attrs?, Pmod_structure(x));
    let functor_ = (~loc=?, ~attrs=?, arg, body) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pmod_functor(arg, body));
    let apply = (~loc=?, ~attrs=?, m1, m2) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pmod_apply(m1, m2));
    let constraint_ = (~loc=?, ~attrs=?, m, mty) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pmod_constraint(m, mty));
    let unpack = (~loc=?, ~attrs=?, e) =>
      mk(~loc?, ~attrs?, Pmod_unpack(e));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pmod_extension(a));
  };

  module Sig = {
    let mk = (~loc=default_loc^, d) => {psig_desc: d, psig_loc: loc};

    let value = (~loc=?, a) => mk(~loc?, Psig_value(a));
    let type_ = (~loc=?, rec_flag, a) =>
      mk(~loc?, [@implicit_arity] Psig_type(rec_flag, a));
    let type_subst = (~loc=?, a) => mk(~loc?, Psig_typesubst(a));
    let type_extension = (~loc=?, a) => mk(~loc?, Psig_typext(a));
    let exception_ = (~loc=?, a) => mk(~loc?, Psig_exception(a));
    let module_ = (~loc=?, a) => mk(~loc?, Psig_module(a));
    let mod_subst = (~loc=?, a) => mk(~loc?, Psig_modsubst(a));
    let rec_module = (~loc=?, a) => mk(~loc?, Psig_recmodule(a));
    let modtype = (~loc=?, a) => mk(~loc?, Psig_modtype(a));
    let open_ = (~loc=?, a) => mk(~loc?, Psig_open(a));
    let include_ = (~loc=?, a) => mk(~loc?, Psig_include(a));
    let class_ = (~loc=?, a) => mk(~loc?, Psig_class(a));
    let class_type = (~loc=?, a) => mk(~loc?, Psig_class_type(a));
    let extension = (~loc=?, ~attrs=[], a) =>
      mk(~loc?, [@implicit_arity] Psig_extension(a, attrs));
    let attribute = (~loc=?, a) => mk(~loc?, Psig_attribute(a));
    let text = txt => {
      let f_txt = List.filter(ds => docstring_body(ds) != "", txt);
      List.map(
        ds => attribute(~loc=docstring_loc(ds), text_attr(ds)),
        f_txt,
      );
    };
  };

  module Str = {
    let mk = (~loc=default_loc^, d) => {pstr_desc: d, pstr_loc: loc};

    let eval = (~loc=?, ~attrs=[], a) =>
      mk(~loc?, [@implicit_arity] Pstr_eval(a, attrs));
    let value = (~loc=?, a, b) =>
      mk(~loc?, [@implicit_arity] Pstr_value(a, b));
    let primitive = (~loc=?, a) => mk(~loc?, Pstr_primitive(a));
    let type_ = (~loc=?, rec_flag, a) =>
      mk(~loc?, [@implicit_arity] Pstr_type(rec_flag, a));
    let type_extension = (~loc=?, a) => mk(~loc?, Pstr_typext(a));
    let exception_ = (~loc=?, a) => mk(~loc?, Pstr_exception(a));
    let module_ = (~loc=?, a) => mk(~loc?, Pstr_module(a));
    let rec_module = (~loc=?, a) => mk(~loc?, Pstr_recmodule(a));
    let modtype = (~loc=?, a) => mk(~loc?, Pstr_modtype(a));
    let open_ = (~loc=?, a) => mk(~loc?, Pstr_open(a));
    let class_ = (~loc=?, a) => mk(~loc?, Pstr_class(a));
    let class_type = (~loc=?, a) => mk(~loc?, Pstr_class_type(a));
    let include_ = (~loc=?, a) => mk(~loc?, Pstr_include(a));
    let extension = (~loc=?, ~attrs=[], a) =>
      mk(~loc?, [@implicit_arity] Pstr_extension(a, attrs));
    let attribute = (~loc=?, a) => mk(~loc?, Pstr_attribute(a));
    let text = txt => {
      let f_txt = List.filter(ds => docstring_body(ds) != "", txt);
      List.map(
        ds => attribute(~loc=docstring_loc(ds), text_attr(ds)),
        f_txt,
      );
    };
  };

  module Cl = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      pcl_desc: d,
      pcl_loc: loc,
      pcl_attributes: attrs,
    };
    let attr = (d, a) => {...d, pcl_attributes: d.pcl_attributes @ [a]};

    let constr = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_constr(a, b));
    let structure = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcl_structure(a));
    let fun_ = (~loc=?, ~attrs=?, a, b, c, d) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_fun(a, b, c, d));
    let apply = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_apply(a, b));
    let let_ = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_let(a, b, c));
    let constraint_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_constraint(a, b));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcl_extension(a));
    let open_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcl_open(a, b));
  };

  module Cty = {
    let mk = (~loc=default_loc^, ~attrs=[], d) => {
      pcty_desc: d,
      pcty_loc: loc,
      pcty_attributes: attrs,
    };
    let attr = (d, a) => {...d, pcty_attributes: d.pcty_attributes @ [a]};

    let constr = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcty_constr(a, b));
    let signature = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcty_signature(a));
    let arrow = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcty_arrow(a, b, c));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcty_extension(a));
    let open_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcty_open(a, b));
  };

  module Ctf = {
    let mk = (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, d) => {
      pctf_desc: d,
      pctf_loc: loc,
      pctf_attributes: add_docs_attrs(docs, attrs),
    };

    let inherit_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pctf_inherit(a));
    let val_ = (~loc=?, ~attrs=?, a, b, c, d) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pctf_val(a, b, c, d));
    let method = (~loc=?, ~attrs=?, a, b, c, d) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pctf_method(a, b, c, d));
    let constraint_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pctf_constraint(a, b));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pctf_extension(a));
    let attribute = (~loc=?, a) => mk(~loc?, Pctf_attribute(a));
    let text = txt => {
      let f_txt = List.filter(ds => docstring_body(ds) != "", txt);
      List.map(
        ds => attribute(~loc=docstring_loc(ds), text_attr(ds)),
        f_txt,
      );
    };

    let attr = (d, a) => {...d, pctf_attributes: d.pctf_attributes @ [a]};
  };

  module Cf = {
    let mk = (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, d) => {
      pcf_desc: d,
      pcf_loc: loc,
      pcf_attributes: add_docs_attrs(docs, attrs),
    };

    let inherit_ = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcf_inherit(a, b, c));
    let val_ = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcf_val(a, b, c));
    let method = (~loc=?, ~attrs=?, a, b, c) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcf_method(a, b, c));
    let constraint_ = (~loc=?, ~attrs=?, a, b) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Pcf_constraint(a, b));
    let initializer_ = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcf_initializer(a));
    let extension = (~loc=?, ~attrs=?, a) =>
      mk(~loc?, ~attrs?, Pcf_extension(a));
    let attribute = (~loc=?, a) => mk(~loc?, Pcf_attribute(a));
    let text = txt => {
      let f_txt = List.filter(ds => docstring_body(ds) != "", txt);
      List.map(
        ds => attribute(~loc=docstring_loc(ds), text_attr(ds)),
        f_txt,
      );
    };

    let virtual_ = ct => Cfk_virtual(ct);
    let concrete = (o, e) => [@implicit_arity] Cfk_concrete(o, e);

    let attr = (d, a) => {...d, pcf_attributes: d.pcf_attributes @ [a]};
  };

  module Val = {
    let mk =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, ~prim=[], name, typ) => {
      pval_name: name,
      pval_type: typ,
      pval_attributes: add_docs_attrs(docs, attrs),
      pval_loc: loc,
      pval_prim: prim,
    };
  };

  module Md = {
    let mk =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, ~text=[], name, typ) => {
      pmd_name: name,
      pmd_type: typ,
      pmd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pmd_loc: loc,
    };
  };

  module Ms = {
    let mk =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, ~text=[], name, syn) => {
      pms_name: name,
      pms_manifest: syn,
      pms_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pms_loc: loc,
    };
  };

  module Mtd = {
    let mk =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~text=[],
          ~typ=?,
          name,
        ) => {
      pmtd_name: name,
      pmtd_type: typ,
      pmtd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pmtd_loc: loc,
    };
  };

  module Mb = {
    let mk =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, ~text=[], name, expr) => {
      pmb_name: name,
      pmb_expr: expr,
      pmb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pmb_loc: loc,
    };
  };

  module Opn = {
    let mk =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~override=Fresh,
          expr,
        ) => {
      popen_expr: expr,
      popen_override: override,
      popen_loc: loc,
      popen_attributes: add_docs_attrs(docs, attrs),
    };
  };

  module Incl = {
    let mk = (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, mexpr) => {
      pincl_mod: mexpr,
      pincl_loc: loc,
      pincl_attributes: add_docs_attrs(docs, attrs),
    };
  };

  module Vb = {
    let mk =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, ~text=[], pat, expr) => {
      pvb_pat: pat,
      pvb_expr: expr,
      pvb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pvb_loc: loc,
    };
  };

  module Ci = {
    let mk =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~text=[],
          ~virt=Concrete,
          ~params=[],
          name,
          expr,
        ) => {
      pci_virt: virt,
      pci_params: params,
      pci_name: name,
      pci_expr: expr,
      pci_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      pci_loc: loc,
    };
  };

  module Type = {
    let mk =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~text=[],
          ~params=[],
          ~cstrs=[],
          ~kind=Ptype_abstract,
          ~priv=Public,
          ~manifest=?,
          name,
        ) => {
      ptype_name: name,
      ptype_params: params,
      ptype_cstrs: cstrs,
      ptype_kind: kind,
      ptype_private: priv,
      ptype_manifest: manifest,
      ptype_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
      ptype_loc: loc,
    };

    let constructor =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~info=empty_info,
          ~args=Pcstr_tuple([]),
          ~res=?,
          name,
        ) => {
      pcd_name: name,
      pcd_args: args,
      pcd_res: res,
      pcd_loc: loc,
      pcd_attributes: add_info_attrs(info, attrs),
    };

    let field =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~info=empty_info,
          ~mut=Immutable,
          name,
          typ,
        ) => {
      pld_name: name,
      pld_mutable: mut,
      pld_type: typ,
      pld_loc: loc,
      pld_attributes: add_info_attrs(info, attrs),
    };
  };

  /** Type extensions */
  module Te = {
    let mk =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~params=[],
          ~priv=Public,
          path,
          constructors,
        ) => {
      ptyext_path: path,
      ptyext_params: params,
      ptyext_constructors: constructors,
      ptyext_private: priv,
      ptyext_loc: loc,
      ptyext_attributes: add_docs_attrs(docs, attrs),
    };

    let mk_exception =
        (~loc=default_loc^, ~attrs=[], ~docs=empty_docs, constructor) => {
      ptyexn_constructor: constructor,
      ptyexn_loc: loc,
      ptyexn_attributes: add_docs_attrs(docs, attrs),
    };

    let constructor =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~info=empty_info,
          name,
          kind,
        ) => {
      pext_name: name,
      pext_kind: kind,
      pext_loc: loc,
      pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs)),
    };

    let decl =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~info=empty_info,
          ~args=Pcstr_tuple([]),
          ~res=?,
          name,
        ) => {
      pext_name: name,
      pext_kind: [@implicit_arity] Pext_decl(args, res),
      pext_loc: loc,
      pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs)),
    };

    let rebind =
        (
          ~loc=default_loc^,
          ~attrs=[],
          ~docs=empty_docs,
          ~info=empty_info,
          name,
          lid,
        ) => {
      pext_name: name,
      pext_kind: Pext_rebind(lid),
      pext_loc: loc,
      pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs)),
    };
  };

  module Csig = {
    let mk = (self, fields) => {pcsig_self: self, pcsig_fields: fields};
  };

  module Cstr = {
    let mk = (self, fields) => {pcstr_self: self, pcstr_fields: fields};
  };

  /** Row fields */
  module Rf = {
    let mk = (~loc=default_loc^, ~attrs=[], desc) => {
      prf_desc: desc,
      prf_loc: loc,
      prf_attributes: attrs,
    };
    let tag = (~loc=?, ~attrs=?, label, const, tys) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Rtag(label, const, tys));
    let inherit_ = (~loc=?, ty) => mk(~loc?, Rinherit(ty));
  };

  /** Object fields */
  module Of = {
    let mk = (~loc=default_loc^, ~attrs=[], desc) => {
      pof_desc: desc,
      pof_loc: loc,
      pof_attributes: attrs,
    };
    let tag = (~loc=?, ~attrs=?, label, ty) =>
      mk(~loc?, ~attrs?, [@implicit_arity] Otag(label, ty));
    let inherit_ = (~loc=?, ty) => mk(~loc?, Oinherit(ty));
  };
};

module Ast_mapper: {
  open Parsetree;

  /** {1 A generic Parsetree mapper} */;

  /** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. */

  type mapper /*IF_CURRENT = Ast_mapper.mapper */ = {
    attribute: (mapper, attribute) => attribute,
    attributes: (mapper, list(attribute)) => list(attribute),
    binding_op: (mapper, binding_op) => binding_op,
    case: (mapper, case) => case,
    cases: (mapper, list(case)) => list(case),
    class_declaration: (mapper, class_declaration) => class_declaration,
    class_description: (mapper, class_description) => class_description,
    class_expr: (mapper, class_expr) => class_expr,
    class_field: (mapper, class_field) => class_field,
    class_signature: (mapper, class_signature) => class_signature,
    class_structure: (mapper, class_structure) => class_structure,
    class_type: (mapper, class_type) => class_type,
    class_type_declaration:
      (mapper, class_type_declaration) => class_type_declaration,
    class_type_field: (mapper, class_type_field) => class_type_field,
    constructor_declaration:
      (mapper, constructor_declaration) => constructor_declaration,
    expr: (mapper, expression) => expression,
    extension: (mapper, extension) => extension,
    extension_constructor:
      (mapper, extension_constructor) => extension_constructor,
    include_declaration: (mapper, include_declaration) => include_declaration,
    include_description: (mapper, include_description) => include_description,
    label_declaration: (mapper, label_declaration) => label_declaration,
    location: (mapper, Location.t) => Location.t,
    module_binding: (mapper, module_binding) => module_binding,
    module_declaration: (mapper, module_declaration) => module_declaration,
    module_substitution: (mapper, module_substitution) => module_substitution,
    module_expr: (mapper, module_expr) => module_expr,
    module_type: (mapper, module_type) => module_type,
    module_type_declaration:
      (mapper, module_type_declaration) => module_type_declaration,
    open_declaration: (mapper, open_declaration) => open_declaration,
    open_description: (mapper, open_description) => open_description,
    pat: (mapper, pattern) => pattern,
    payload: (mapper, payload) => payload,
    signature: (mapper, signature) => signature,
    signature_item: (mapper, signature_item) => signature_item,
    structure: (mapper, structure) => structure,
    structure_item: (mapper, structure_item) => structure_item,
    typ: (mapper, core_type) => core_type,
    type_declaration: (mapper, type_declaration) => type_declaration,
    type_extension: (mapper, type_extension) => type_extension,
    type_exception: (mapper, type_exception) => type_exception,
    type_kind: (mapper, type_kind) => type_kind,
    value_binding: (mapper, value_binding) => value_binding,
    value_description: (mapper, value_description) => value_description,
    with_constraint: (mapper, with_constraint) => with_constraint,
  };

  /** A default mapper, which implements a "deep identity" mapping. */

  let default_mapper: mapper;

  /** {1 Apply mappers to compilation units} */;

  /** Can be used within a ppx preprocessor to know which tool is
      calling it ["ocamlc"], ["ocamlopt"], ["ocamldoc"], ["ocamldep"],
      ["ocaml"], ...  Some global variables that reflect command-line
      options are automatically synchronized between the calling tool
      and the ppx preprocessor: {!Clflags.include_dirs},
      {!Load_path}, {!Clflags.open_modules}, {!Clflags.for_package},
      {!Clflags.debug}. */

  let tool_name: unit => string;

  /** Apply a mapper (parametrized by the unit name) to a dumped
      parsetree found in the [source] file and put the result in the
      [target] file. The [structure] or [signature] field of the mapper
      is applied to the implementation or interface.  */

  let apply: (~source: string, ~target: string, mapper) => unit;

  /** Entry point to call to implement a standalone -ppx rewriter from a
      mapper, parametrized by the command line arguments.  The current
      unit name can be obtained from {!Location.input_name}.  This
      function implements proper error reporting for uncaught
      exceptions. */

  let run_main: (list(string) => mapper) => unit;

  /** {1 Registration API} */;

  let register_function: ref((string, list(string) => mapper) => unit);

  /** Apply the [register_function].  The default behavior is to run the
      mapper immediately, taking arguments from the process command
      line.  This is to support a scenario where a mapper is linked as a
      stand-alone executable.

      It is possible to overwrite the [register_function] to define
      "-ppx drivers", which combine several mappers in a single process.
      Typically, a driver starts by defining [register_function] to a
      custom implementation, then lets ppx rewriters (linked statically
      or dynamically) register themselves, and then run all or some of
      them.  It is also possible to have -ppx drivers apply rewriters to
      only specific parts of an AST.

      The first argument to [register] is a symbolic name to be used by
      the ppx driver.  */

  let register: (string, list(string) => mapper) => unit;

  /** {1 Convenience functions to write mappers} */;

  let map_opt: ('a => 'b, option('a)) => option('b);

  /** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. */

  let extension_of_error: Locations.location_error => extension;

  /** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. */

  let attribute_of_warning: (Location.t, string) => attribute;

  include Locations.Helpers_intf;

  /** {1 Helper functions to call external mappers} */;

  /** Extract information from the current environment and encode it
      into an attribute which is prepended to the list of structure
      items in order to pass the information to an external
      processor. */

  let add_ppx_context_str:
    (~tool_name: string, Parsetree.structure) => Parsetree.structure;

  /** Same as [add_ppx_context_str], but for signatures. */

  let add_ppx_context_sig:
    (~tool_name: string, Parsetree.signature) => Parsetree.signature;

  /** Drop the ocaml.ppx.context attribute from a structure.  If
      [restore] is true, also restore the associated data in the current
      process. */

  let drop_ppx_context_str:
    (~restore: bool, Parsetree.structure) => Parsetree.structure;

  /** Same as [drop_ppx_context_str], but for signatures. */

  let drop_ppx_context_sig:
    (~restore: bool, Parsetree.signature) => Parsetree.signature;

  /** {1 Cookies} */;

  /** Cookies are used to pass information from a ppx processor to
      a further invocation of itself, when called from the OCaml
      toplevel (or other tools that support cookies). */;

  let set_cookie: (string, Parsetree.expression) => unit;
  let get_cookie: string => option(Parsetree.expression);
} = {
  open Parsetree;
  open Ast_helper;
  open Location;

  module String = Misc.Stdlib.String;

  type mapper /*IF_CURRENT = Ast_mapper.mapper */ = {
    attribute: (mapper, attribute) => attribute,
    attributes: (mapper, list(attribute)) => list(attribute),
    binding_op: (mapper, binding_op) => binding_op,
    case: (mapper, case) => case,
    cases: (mapper, list(case)) => list(case),
    class_declaration: (mapper, class_declaration) => class_declaration,
    class_description: (mapper, class_description) => class_description,
    class_expr: (mapper, class_expr) => class_expr,
    class_field: (mapper, class_field) => class_field,
    class_signature: (mapper, class_signature) => class_signature,
    class_structure: (mapper, class_structure) => class_structure,
    class_type: (mapper, class_type) => class_type,
    class_type_declaration:
      (mapper, class_type_declaration) => class_type_declaration,
    class_type_field: (mapper, class_type_field) => class_type_field,
    constructor_declaration:
      (mapper, constructor_declaration) => constructor_declaration,
    expr: (mapper, expression) => expression,
    extension: (mapper, extension) => extension,
    extension_constructor:
      (mapper, extension_constructor) => extension_constructor,
    include_declaration: (mapper, include_declaration) => include_declaration,
    include_description: (mapper, include_description) => include_description,
    label_declaration: (mapper, label_declaration) => label_declaration,
    location: (mapper, Location.t) => Location.t,
    module_binding: (mapper, module_binding) => module_binding,
    module_declaration: (mapper, module_declaration) => module_declaration,
    module_substitution: (mapper, module_substitution) => module_substitution,
    module_expr: (mapper, module_expr) => module_expr,
    module_type: (mapper, module_type) => module_type,
    module_type_declaration:
      (mapper, module_type_declaration) => module_type_declaration,
    open_declaration: (mapper, open_declaration) => open_declaration,
    open_description: (mapper, open_description) => open_description,
    pat: (mapper, pattern) => pattern,
    payload: (mapper, payload) => payload,
    signature: (mapper, signature) => signature,
    signature_item: (mapper, signature_item) => signature_item,
    structure: (mapper, structure) => structure,
    structure_item: (mapper, structure_item) => structure_item,
    typ: (mapper, core_type) => core_type,
    type_declaration: (mapper, type_declaration) => type_declaration,
    type_extension: (mapper, type_extension) => type_extension,
    type_exception: (mapper, type_exception) => type_exception,
    type_kind: (mapper, type_kind) => type_kind,
    value_binding: (mapper, value_binding) => value_binding,
    value_description: (mapper, value_description) => value_description,
    with_constraint: (mapper, with_constraint) => with_constraint,
  };

  let map_fst = (f, (x, y)) => (f(x), y);
  let map_snd = (f, (x, y)) => (x, f(y));
  let map_tuple = (f1, f2, (x, y)) => (f1(x), f2(y));
  let map_tuple3 = (f1, f2, f3, (x, y, z)) => (f1(x), f2(y), f3(z));
  let map_opt = f =>
    fun
    | None => None
    | Some(x) => Some(f(x));

  let map_loc = (sub, {loc, txt}) => {loc: sub.location(sub, loc), txt};

  module T = {
    /* Type expressions for the core language */

    let row_field = (sub, {prf_desc, prf_loc, prf_attributes}) => {
      let loc = sub.location(sub, prf_loc);
      let attrs = sub.attributes(sub, prf_attributes);
      let desc =
        switch (prf_desc) {
        | [@implicit_arity] Rtag(l, b, tl) =>
          [@implicit_arity]
          Rtag(map_loc(sub, l), b, List.map(sub.typ(sub), tl))
        | Rinherit(t) => Rinherit(sub.typ(sub, t))
        };

      Rf.mk(~loc, ~attrs, desc);
    };

    let object_field = (sub, {pof_desc, pof_loc, pof_attributes}) => {
      let loc = sub.location(sub, pof_loc);
      let attrs = sub.attributes(sub, pof_attributes);
      let desc =
        switch (pof_desc) {
        | [@implicit_arity] Otag(l, t) =>
          [@implicit_arity] Otag(map_loc(sub, l), sub.typ(sub, t))
        | Oinherit(t) => Oinherit(sub.typ(sub, t))
        };

      Of.mk(~loc, ~attrs, desc);
    };

    let map = (sub, {ptyp_desc: desc, ptyp_loc: loc, ptyp_attributes: attrs}) => {
      open Typ;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Ptyp_any => any(~loc, ~attrs, ())
      | Ptyp_var(s) => var(~loc, ~attrs, s)
      | [@implicit_arity] Ptyp_arrow(lab, t1, t2) =>
        arrow(~loc, ~attrs, lab, sub.typ(sub, t1), sub.typ(sub, t2))
      | Ptyp_tuple(tyl) => tuple(~loc, ~attrs, List.map(sub.typ(sub), tyl))
      | [@implicit_arity] Ptyp_constr(lid, tl) =>
        constr(~loc, ~attrs, map_loc(sub, lid), List.map(sub.typ(sub), tl))
      | [@implicit_arity] Ptyp_object(l, o) =>
        object_(~loc, ~attrs, List.map(object_field(sub), l), o)
      | [@implicit_arity] Ptyp_class(lid, tl) =>
        class_(~loc, ~attrs, map_loc(sub, lid), List.map(sub.typ(sub), tl))
      | [@implicit_arity] Ptyp_alias(t, s) =>
        alias(~loc, ~attrs, sub.typ(sub, t), s)
      | [@implicit_arity] Ptyp_variant(rl, b, ll) =>
        variant(~loc, ~attrs, List.map(row_field(sub), rl), b, ll)
      | [@implicit_arity] Ptyp_poly(sl, t) =>
        poly(~loc, ~attrs, List.map(map_loc(sub), sl), sub.typ(sub, t))
      | [@implicit_arity] Ptyp_package(lid, l) =>
        package(
          ~loc,
          ~attrs,
          map_loc(sub, lid),
          List.map(map_tuple(map_loc(sub), sub.typ(sub)), l),
        )
      | Ptyp_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };

    let map_type_declaration =
        (
          sub,
          {
            ptype_name,
            ptype_params,
            ptype_cstrs,
            ptype_kind,
            ptype_private,
            ptype_manifest,
            ptype_attributes,
            ptype_loc,
          },
        ) => {
      let loc = sub.location(sub, ptype_loc);
      let attrs = sub.attributes(sub, ptype_attributes);
      Type.mk(
        ~loc,
        ~attrs,
        map_loc(sub, ptype_name),
        ~params=List.map(map_fst(sub.typ(sub)), ptype_params),
        ~priv=ptype_private,
        ~cstrs=
          List.map(
            map_tuple3(sub.typ(sub), sub.typ(sub), sub.location(sub)),
            ptype_cstrs,
          ),
        ~kind=sub.type_kind(sub, ptype_kind),
        ~manifest=?map_opt(sub.typ(sub), ptype_manifest),
      );
    };

    let map_type_kind = sub =>
      fun
      | Ptype_abstract => Ptype_abstract
      | Ptype_variant(l) =>
        Ptype_variant(List.map(sub.constructor_declaration(sub), l))
      | Ptype_record(l) =>
        Ptype_record(List.map(sub.label_declaration(sub), l))
      | Ptype_open => Ptype_open;

    let map_constructor_arguments = sub =>
      fun
      | Pcstr_tuple(l) => Pcstr_tuple(List.map(sub.typ(sub), l))
      | Pcstr_record(l) =>
        Pcstr_record(List.map(sub.label_declaration(sub), l));

    let map_type_extension =
        (
          sub,
          {
            ptyext_path,
            ptyext_params,
            ptyext_constructors,
            ptyext_private,
            ptyext_loc,
            ptyext_attributes,
          },
        ) => {
      let loc = sub.location(sub, ptyext_loc);
      let attrs = sub.attributes(sub, ptyext_attributes);
      Te.mk(
        ~loc,
        ~attrs,
        map_loc(sub, ptyext_path),
        List.map(sub.extension_constructor(sub), ptyext_constructors),
        ~params=List.map(map_fst(sub.typ(sub)), ptyext_params),
        ~priv=ptyext_private,
      );
    };

    let map_type_exception =
        (sub, {ptyexn_constructor, ptyexn_loc, ptyexn_attributes}) => {
      let loc = sub.location(sub, ptyexn_loc);
      let attrs = sub.attributes(sub, ptyexn_attributes);
      Te.mk_exception(
        ~loc,
        ~attrs,
        sub.extension_constructor(sub, ptyexn_constructor),
      );
    };

    let map_extension_constructor_kind = sub =>
      fun
      | [@implicit_arity] Pext_decl(ctl, cto) =>
        [@implicit_arity]
        Pext_decl(
          map_constructor_arguments(sub, ctl),
          map_opt(sub.typ(sub), cto),
        )
      | Pext_rebind(li) => Pext_rebind(map_loc(sub, li));

    let map_extension_constructor =
        (sub, {pext_name, pext_kind, pext_loc, pext_attributes}) => {
      let loc = sub.location(sub, pext_loc);
      let attrs = sub.attributes(sub, pext_attributes);
      Te.constructor(
        ~loc,
        ~attrs,
        map_loc(sub, pext_name),
        map_extension_constructor_kind(sub, pext_kind),
      );
    };
  };

  module CT = {
    /* Type expressions for the class language */

    let map = (sub, {pcty_loc: loc, pcty_desc: desc, pcty_attributes: attrs}) => {
      open Cty;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | [@implicit_arity] Pcty_constr(lid, tys) =>
        constr(
          ~loc,
          ~attrs,
          map_loc(sub, lid),
          List.map(sub.typ(sub), tys),
        )
      | Pcty_signature(x) =>
        signature(~loc, ~attrs, sub.class_signature(sub, x))
      | [@implicit_arity] Pcty_arrow(lab, t, ct) =>
        arrow(~loc, ~attrs, lab, sub.typ(sub, t), sub.class_type(sub, ct))
      | Pcty_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      | [@implicit_arity] Pcty_open(o, ct) =>
        open_(
          ~loc,
          ~attrs,
          sub.open_description(sub, o),
          sub.class_type(sub, ct),
        )
      };
    };

    let map_field =
        (sub, {pctf_desc: desc, pctf_loc: loc, pctf_attributes: attrs}) => {
      open Ctf;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Pctf_inherit(ct) => inherit_(~loc, ~attrs, sub.class_type(sub, ct))
      | [@implicit_arity] Pctf_val(s, m, v, t) =>
        val_(~loc, ~attrs, map_loc(sub, s), m, v, sub.typ(sub, t))
      | [@implicit_arity] Pctf_method(s, p, v, t) =>
        method(~loc, ~attrs, map_loc(sub, s), p, v, sub.typ(sub, t))
      | [@implicit_arity] Pctf_constraint(t1, t2) =>
        constraint_(~loc, ~attrs, sub.typ(sub, t1), sub.typ(sub, t2))
      | Pctf_attribute(x) => attribute(~loc, sub.attribute(sub, x))
      | Pctf_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };

    let map_signature = (sub, {pcsig_self, pcsig_fields}) =>
      Csig.mk(
        sub.typ(sub, pcsig_self),
        List.map(sub.class_type_field(sub), pcsig_fields),
      );
  };

  let map_functor_param = sub =>
    fun
    | Unit => Unit
    | [@implicit_arity] Named(s, mt) =>
      [@implicit_arity] Named(map_loc(sub, s), sub.module_type(sub, mt));

  module MT = {
    /* Type expressions for the module language */

    let map = (sub, {pmty_desc: desc, pmty_loc: loc, pmty_attributes: attrs}) => {
      open Mty;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Pmty_ident(s) => ident(~loc, ~attrs, map_loc(sub, s))
      | Pmty_alias(s) => alias(~loc, ~attrs, map_loc(sub, s))
      | Pmty_signature(sg) => signature(~loc, ~attrs, sub.signature(sub, sg))
      | [@implicit_arity] Pmty_functor(param, mt) =>
        functor_(
          ~loc,
          ~attrs,
          map_functor_param(sub, param),
          sub.module_type(sub, mt),
        )
      | [@implicit_arity] Pmty_with(mt, l) =>
        with_(
          ~loc,
          ~attrs,
          sub.module_type(sub, mt),
          List.map(sub.with_constraint(sub), l),
        )
      | Pmty_typeof(me) => typeof_(~loc, ~attrs, sub.module_expr(sub, me))
      | Pmty_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };

    let map_with_constraint = sub =>
      fun
      | [@implicit_arity] Pwith_type(lid, d) =>
        [@implicit_arity]
        Pwith_type(map_loc(sub, lid), sub.type_declaration(sub, d))
      | [@implicit_arity] Pwith_module(lid, lid2) =>
        [@implicit_arity]
        Pwith_module(map_loc(sub, lid), map_loc(sub, lid2))
      | [@implicit_arity] Pwith_typesubst(lid, d) =>
        [@implicit_arity]
        Pwith_typesubst(map_loc(sub, lid), sub.type_declaration(sub, d))
      | [@implicit_arity] Pwith_modsubst(s, lid) =>
        [@implicit_arity]
        Pwith_modsubst(map_loc(sub, s), map_loc(sub, lid));

    let map_signature_item = (sub, {psig_desc: desc, psig_loc: loc}) => {
      open Sig;
      let loc = sub.location(sub, loc);
      switch (desc) {
      | Psig_value(vd) => value(~loc, sub.value_description(sub, vd))
      | [@implicit_arity] Psig_type(rf, l) =>
        type_(~loc, rf, List.map(sub.type_declaration(sub), l))
      | Psig_typesubst(l) =>
        type_subst(~loc, List.map(sub.type_declaration(sub), l))
      | Psig_typext(te) => type_extension(~loc, sub.type_extension(sub, te))
      | Psig_exception(ed) => exception_(~loc, sub.type_exception(sub, ed))
      | Psig_module(x) => module_(~loc, sub.module_declaration(sub, x))
      | Psig_modsubst(x) => mod_subst(~loc, sub.module_substitution(sub, x))
      | Psig_recmodule(l) =>
        rec_module(~loc, List.map(sub.module_declaration(sub), l))
      | Psig_modtype(x) => modtype(~loc, sub.module_type_declaration(sub, x))
      | Psig_open(x) => open_(~loc, sub.open_description(sub, x))
      | Psig_include(x) => include_(~loc, sub.include_description(sub, x))
      | Psig_class(l) =>
        class_(~loc, List.map(sub.class_description(sub), l))
      | Psig_class_type(l) =>
        class_type(~loc, List.map(sub.class_type_declaration(sub), l))
      | [@implicit_arity] Psig_extension(x, attrs) =>
        let attrs = sub.attributes(sub, attrs);
        extension(~loc, ~attrs, sub.extension(sub, x));
      | Psig_attribute(x) => attribute(~loc, sub.attribute(sub, x))
      };
    };
  };

  module M = {
    /* Value expressions for the module language */

    let map = (sub, {pmod_loc: loc, pmod_desc: desc, pmod_attributes: attrs}) => {
      open Mod;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Pmod_ident(x) => ident(~loc, ~attrs, map_loc(sub, x))
      | Pmod_structure(str) =>
        structure(~loc, ~attrs, sub.structure(sub, str))
      | [@implicit_arity] Pmod_functor(param, body) =>
        functor_(
          ~loc,
          ~attrs,
          map_functor_param(sub, param),
          sub.module_expr(sub, body),
        )
      | [@implicit_arity] Pmod_apply(m1, m2) =>
        apply(
          ~loc,
          ~attrs,
          sub.module_expr(sub, m1),
          sub.module_expr(sub, m2),
        )
      | [@implicit_arity] Pmod_constraint(m, mty) =>
        constraint_(
          ~loc,
          ~attrs,
          sub.module_expr(sub, m),
          sub.module_type(sub, mty),
        )
      | Pmod_unpack(e) => unpack(~loc, ~attrs, sub.expr(sub, e))
      | Pmod_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };

    let map_structure_item = (sub, {pstr_loc: loc, pstr_desc: desc}) => {
      open Str;
      let loc = sub.location(sub, loc);
      switch (desc) {
      | [@implicit_arity] Pstr_eval(x, attrs) =>
        let attrs = sub.attributes(sub, attrs);
        eval(~loc, ~attrs, sub.expr(sub, x));
      | [@implicit_arity] Pstr_value(r, vbs) =>
        value(~loc, r, List.map(sub.value_binding(sub), vbs))
      | Pstr_primitive(vd) => primitive(~loc, sub.value_description(sub, vd))
      | [@implicit_arity] Pstr_type(rf, l) =>
        type_(~loc, rf, List.map(sub.type_declaration(sub), l))
      | Pstr_typext(te) => type_extension(~loc, sub.type_extension(sub, te))
      | Pstr_exception(ed) => exception_(~loc, sub.type_exception(sub, ed))
      | Pstr_module(x) => module_(~loc, sub.module_binding(sub, x))
      | Pstr_recmodule(l) =>
        rec_module(~loc, List.map(sub.module_binding(sub), l))
      | Pstr_modtype(x) => modtype(~loc, sub.module_type_declaration(sub, x))
      | Pstr_open(x) => open_(~loc, sub.open_declaration(sub, x))
      | Pstr_class(l) =>
        class_(~loc, List.map(sub.class_declaration(sub), l))
      | Pstr_class_type(l) =>
        class_type(~loc, List.map(sub.class_type_declaration(sub), l))
      | Pstr_include(x) => include_(~loc, sub.include_declaration(sub, x))
      | [@implicit_arity] Pstr_extension(x, attrs) =>
        let attrs = sub.attributes(sub, attrs);
        extension(~loc, ~attrs, sub.extension(sub, x));
      | Pstr_attribute(x) => attribute(~loc, sub.attribute(sub, x))
      };
    };
  };

  module E = {
    /* Value expressions for the core language */

    let map = (sub, {pexp_loc: loc, pexp_desc: desc, pexp_attributes: attrs}) => {
      open Exp;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Pexp_ident(x) => ident(~loc, ~attrs, map_loc(sub, x))
      | Pexp_constant(x) => constant(~loc, ~attrs, x)
      | [@implicit_arity] Pexp_let(r, vbs, e) =>
        let_(
          ~loc,
          ~attrs,
          r,
          List.map(sub.value_binding(sub), vbs),
          sub.expr(sub, e),
        )
      | [@implicit_arity] Pexp_fun(lab, def, p, e) =>
        fun_(
          ~loc,
          ~attrs,
          lab,
          map_opt(sub.expr(sub), def),
          sub.pat(sub, p),
          sub.expr(sub, e),
        )
      | Pexp_function(pel) => function_(~loc, ~attrs, sub.cases(sub, pel))
      | [@implicit_arity] Pexp_apply(e, l) =>
        apply(
          ~loc,
          ~attrs,
          sub.expr(sub, e),
          List.map(map_snd(sub.expr(sub)), l),
        )
      | [@implicit_arity] Pexp_match(e, pel) =>
        match(~loc, ~attrs, sub.expr(sub, e), sub.cases(sub, pel))
      | [@implicit_arity] Pexp_try(e, pel) =>
        try_(~loc, ~attrs, sub.expr(sub, e), sub.cases(sub, pel))
      | Pexp_tuple(el) => tuple(~loc, ~attrs, List.map(sub.expr(sub), el))
      | [@implicit_arity] Pexp_construct(lid, arg) =>
        construct(
          ~loc,
          ~attrs,
          map_loc(sub, lid),
          map_opt(sub.expr(sub), arg),
        )
      | [@implicit_arity] Pexp_variant(lab, eo) =>
        variant(~loc, ~attrs, lab, map_opt(sub.expr(sub), eo))
      | [@implicit_arity] Pexp_record(l, eo) =>
        record(
          ~loc,
          ~attrs,
          List.map(map_tuple(map_loc(sub), sub.expr(sub)), l),
          map_opt(sub.expr(sub), eo),
        )
      | [@implicit_arity] Pexp_field(e, lid) =>
        field(~loc, ~attrs, sub.expr(sub, e), map_loc(sub, lid))
      | [@implicit_arity] Pexp_setfield(e1, lid, e2) =>
        setfield(
          ~loc,
          ~attrs,
          sub.expr(sub, e1),
          map_loc(sub, lid),
          sub.expr(sub, e2),
        )
      | Pexp_array(el) => array(~loc, ~attrs, List.map(sub.expr(sub), el))
      | [@implicit_arity] Pexp_ifthenelse(e1, e2, e3) =>
        ifthenelse(
          ~loc,
          ~attrs,
          sub.expr(sub, e1),
          sub.expr(sub, e2),
          map_opt(sub.expr(sub), e3),
        )
      | [@implicit_arity] Pexp_sequence(e1, e2) =>
        sequence(~loc, ~attrs, sub.expr(sub, e1), sub.expr(sub, e2))
      | [@implicit_arity] Pexp_while(e1, e2) =>
        while_(~loc, ~attrs, sub.expr(sub, e1), sub.expr(sub, e2))
      | [@implicit_arity] Pexp_for(p, e1, e2, d, e3) =>
        for_(
          ~loc,
          ~attrs,
          sub.pat(sub, p),
          sub.expr(sub, e1),
          sub.expr(sub, e2),
          d,
          sub.expr(sub, e3),
        )
      | [@implicit_arity] Pexp_coerce(e, t1, t2) =>
        coerce(
          ~loc,
          ~attrs,
          sub.expr(sub, e),
          map_opt(sub.typ(sub), t1),
          sub.typ(sub, t2),
        )
      | [@implicit_arity] Pexp_constraint(e, t) =>
        constraint_(~loc, ~attrs, sub.expr(sub, e), sub.typ(sub, t))
      | [@implicit_arity] Pexp_send(e, s) =>
        send(~loc, ~attrs, sub.expr(sub, e), map_loc(sub, s))
      | Pexp_new(lid) => new_(~loc, ~attrs, map_loc(sub, lid))
      | [@implicit_arity] Pexp_setinstvar(s, e) =>
        setinstvar(~loc, ~attrs, map_loc(sub, s), sub.expr(sub, e))
      | Pexp_override(sel) =>
        override(
          ~loc,
          ~attrs,
          List.map(map_tuple(map_loc(sub), sub.expr(sub)), sel),
        )
      | [@implicit_arity] Pexp_letmodule(s, me, e) =>
        letmodule(
          ~loc,
          ~attrs,
          map_loc(sub, s),
          sub.module_expr(sub, me),
          sub.expr(sub, e),
        )
      | [@implicit_arity] Pexp_letexception(cd, e) =>
        letexception(
          ~loc,
          ~attrs,
          sub.extension_constructor(sub, cd),
          sub.expr(sub, e),
        )
      | Pexp_assert(e) => assert_(~loc, ~attrs, sub.expr(sub, e))
      | Pexp_lazy(e) => lazy_(~loc, ~attrs, sub.expr(sub, e))
      | [@implicit_arity] Pexp_poly(e, t) =>
        poly(~loc, ~attrs, sub.expr(sub, e), map_opt(sub.typ(sub), t))
      | Pexp_object(cls) =>
        object_(~loc, ~attrs, sub.class_structure(sub, cls))
      | [@implicit_arity] Pexp_newtype(s, e) =>
        newtype(~loc, ~attrs, map_loc(sub, s), sub.expr(sub, e))
      | Pexp_pack(me) => pack(~loc, ~attrs, sub.module_expr(sub, me))
      | [@implicit_arity] Pexp_open(o, e) =>
        open_(~loc, ~attrs, sub.open_declaration(sub, o), sub.expr(sub, e))
      | Pexp_letop({let_, ands, body}) =>
        letop(
          ~loc,
          ~attrs,
          sub.binding_op(sub, let_),
          List.map(sub.binding_op(sub), ands),
          sub.expr(sub, body),
        )
      | Pexp_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      | Pexp_unreachable => unreachable(~loc, ~attrs, ())
      };
    };

    let map_binding_op = (sub, {pbop_op, pbop_pat, pbop_exp, pbop_loc}) => {
      open Exp;
      let op = map_loc(sub, pbop_op);
      let pat = sub.pat(sub, pbop_pat);
      let exp = sub.expr(sub, pbop_exp);
      let loc = sub.location(sub, pbop_loc);
      binding_op(op, pat, exp, loc);
    };
  };

  module P = {
    /* Patterns */

    let map = (sub, {ppat_desc: desc, ppat_loc: loc, ppat_attributes: attrs}) => {
      open Pat;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | Ppat_any => any(~loc, ~attrs, ())
      | Ppat_var(s) => var(~loc, ~attrs, map_loc(sub, s))
      | [@implicit_arity] Ppat_alias(p, s) =>
        alias(~loc, ~attrs, sub.pat(sub, p), map_loc(sub, s))
      | Ppat_constant(c) => constant(~loc, ~attrs, c)
      | [@implicit_arity] Ppat_interval(c1, c2) =>
        interval(~loc, ~attrs, c1, c2)
      | Ppat_tuple(pl) => tuple(~loc, ~attrs, List.map(sub.pat(sub), pl))
      | [@implicit_arity] Ppat_construct(l, p) =>
        construct(~loc, ~attrs, map_loc(sub, l), map_opt(sub.pat(sub), p))
      | [@implicit_arity] Ppat_variant(l, p) =>
        variant(~loc, ~attrs, l, map_opt(sub.pat(sub), p))
      | [@implicit_arity] Ppat_record(lpl, cf) =>
        record(
          ~loc,
          ~attrs,
          List.map(map_tuple(map_loc(sub), sub.pat(sub)), lpl),
          cf,
        )
      | Ppat_array(pl) => array(~loc, ~attrs, List.map(sub.pat(sub), pl))
      | [@implicit_arity] Ppat_or(p1, p2) =>
        or_(~loc, ~attrs, sub.pat(sub, p1), sub.pat(sub, p2))
      | [@implicit_arity] Ppat_constraint(p, t) =>
        constraint_(~loc, ~attrs, sub.pat(sub, p), sub.typ(sub, t))
      | Ppat_type(s) => type_(~loc, ~attrs, map_loc(sub, s))
      | Ppat_lazy(p) => lazy_(~loc, ~attrs, sub.pat(sub, p))
      | Ppat_unpack(s) => unpack(~loc, ~attrs, map_loc(sub, s))
      | [@implicit_arity] Ppat_open(lid, p) =>
        open_(~loc, ~attrs, map_loc(sub, lid), sub.pat(sub, p))
      | Ppat_exception(p) => exception_(~loc, ~attrs, sub.pat(sub, p))
      | Ppat_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };
  };

  module CE = {
    /* Value expressions for the class language */

    let map = (sub, {pcl_loc: loc, pcl_desc: desc, pcl_attributes: attrs}) => {
      open Cl;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | [@implicit_arity] Pcl_constr(lid, tys) =>
        constr(
          ~loc,
          ~attrs,
          map_loc(sub, lid),
          List.map(sub.typ(sub), tys),
        )
      | Pcl_structure(s) =>
        structure(~loc, ~attrs, sub.class_structure(sub, s))
      | [@implicit_arity] Pcl_fun(lab, e, p, ce) =>
        fun_(
          ~loc,
          ~attrs,
          lab,
          map_opt(sub.expr(sub), e),
          sub.pat(sub, p),
          sub.class_expr(sub, ce),
        )
      | [@implicit_arity] Pcl_apply(ce, l) =>
        apply(
          ~loc,
          ~attrs,
          sub.class_expr(sub, ce),
          List.map(map_snd(sub.expr(sub)), l),
        )
      | [@implicit_arity] Pcl_let(r, vbs, ce) =>
        let_(
          ~loc,
          ~attrs,
          r,
          List.map(sub.value_binding(sub), vbs),
          sub.class_expr(sub, ce),
        )
      | [@implicit_arity] Pcl_constraint(ce, ct) =>
        constraint_(
          ~loc,
          ~attrs,
          sub.class_expr(sub, ce),
          sub.class_type(sub, ct),
        )
      | Pcl_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      | [@implicit_arity] Pcl_open(o, ce) =>
        open_(
          ~loc,
          ~attrs,
          sub.open_description(sub, o),
          sub.class_expr(sub, ce),
        )
      };
    };

    let map_kind = sub =>
      fun
      | [@implicit_arity] Cfk_concrete(o, e) =>
        [@implicit_arity] Cfk_concrete(o, sub.expr(sub, e))
      | Cfk_virtual(t) => Cfk_virtual(sub.typ(sub, t));

    let map_field =
        (sub, {pcf_desc: desc, pcf_loc: loc, pcf_attributes: attrs}) => {
      open Cf;
      let loc = sub.location(sub, loc);
      let attrs = sub.attributes(sub, attrs);
      switch (desc) {
      | [@implicit_arity] Pcf_inherit(o, ce, s) =>
        inherit_(
          ~loc,
          ~attrs,
          o,
          sub.class_expr(sub, ce),
          map_opt(map_loc(sub), s),
        )
      | [@implicit_arity] Pcf_val(s, m, k) =>
        val_(~loc, ~attrs, map_loc(sub, s), m, map_kind(sub, k))
      | [@implicit_arity] Pcf_method(s, p, k) =>
        method(~loc, ~attrs, map_loc(sub, s), p, map_kind(sub, k))
      | [@implicit_arity] Pcf_constraint(t1, t2) =>
        constraint_(~loc, ~attrs, sub.typ(sub, t1), sub.typ(sub, t2))
      | Pcf_initializer(e) => initializer_(~loc, ~attrs, sub.expr(sub, e))
      | Pcf_attribute(x) => attribute(~loc, sub.attribute(sub, x))
      | Pcf_extension(x) => extension(~loc, ~attrs, sub.extension(sub, x))
      };
    };

    let map_structure = (sub, {pcstr_self, pcstr_fields}) => {
      pcstr_self: sub.pat(sub, pcstr_self),
      pcstr_fields: List.map(sub.class_field(sub), pcstr_fields),
    };

    let class_infos =
        (
          sub,
          f,
          {
            pci_virt,
            pci_params: pl,
            pci_name,
            pci_expr,
            pci_loc,
            pci_attributes,
          },
        ) => {
      let loc = sub.location(sub, pci_loc);
      let attrs = sub.attributes(sub, pci_attributes);
      Ci.mk(
        ~loc,
        ~attrs,
        ~virt=pci_virt,
        ~params=List.map(map_fst(sub.typ(sub)), pl),
        map_loc(sub, pci_name),
        f(pci_expr),
      );
    };
  };

  /* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. */

  let default_mapper = {
    structure: (this, l) => List.map(this.structure_item(this), l),
    structure_item: M.map_structure_item,
    module_expr: M.map,
    signature: (this, l) => List.map(this.signature_item(this), l),
    signature_item: MT.map_signature_item,
    module_type: MT.map,
    with_constraint: MT.map_with_constraint,
    class_declaration: this => CE.class_infos(this, this.class_expr(this)),
    class_expr: CE.map,
    class_field: CE.map_field,
    class_structure: CE.map_structure,
    class_type: CT.map,
    class_type_field: CT.map_field,
    class_signature: CT.map_signature,
    class_type_declaration: this =>
      CE.class_infos(this, this.class_type(this)),
    class_description: this => CE.class_infos(this, this.class_type(this)),
    type_declaration: T.map_type_declaration,
    type_kind: T.map_type_kind,
    typ: T.map,
    type_extension: T.map_type_extension,
    type_exception: T.map_type_exception,
    extension_constructor: T.map_extension_constructor,
    value_description:
      (this, {pval_name, pval_type, pval_prim, pval_loc, pval_attributes}) =>
      Val.mk(
        map_loc(this, pval_name),
        this.typ(this, pval_type),
        ~attrs=this.attributes(this, pval_attributes),
        ~loc=this.location(this, pval_loc),
        ~prim=pval_prim,
      ),
    pat: P.map,
    expr: E.map,
    binding_op: E.map_binding_op,
    module_declaration:
      (this, {pmd_name, pmd_type, pmd_attributes, pmd_loc}) =>
      Md.mk(
        map_loc(this, pmd_name),
        this.module_type(this, pmd_type),
        ~attrs=this.attributes(this, pmd_attributes),
        ~loc=this.location(this, pmd_loc),
      ),
    module_substitution:
      (this, {pms_name, pms_manifest, pms_attributes, pms_loc}) =>
      Ms.mk(
        map_loc(this, pms_name),
        map_loc(this, pms_manifest),
        ~attrs=this.attributes(this, pms_attributes),
        ~loc=this.location(this, pms_loc),
      ),
    module_type_declaration:
      (this, {pmtd_name, pmtd_type, pmtd_attributes, pmtd_loc}) =>
      Mtd.mk(
        map_loc(this, pmtd_name),
        ~typ=?map_opt(this.module_type(this), pmtd_type),
        ~attrs=this.attributes(this, pmtd_attributes),
        ~loc=this.location(this, pmtd_loc),
      ),
    module_binding: (this, {pmb_name, pmb_expr, pmb_attributes, pmb_loc}) =>
      Mb.mk(
        map_loc(this, pmb_name),
        this.module_expr(this, pmb_expr),
        ~attrs=this.attributes(this, pmb_attributes),
        ~loc=this.location(this, pmb_loc),
      ),
    open_declaration:
      (this, {popen_expr, popen_override, popen_attributes, popen_loc}) =>
      Opn.mk(
        this.module_expr(this, popen_expr),
        ~override=popen_override,
        ~loc=this.location(this, popen_loc),
        ~attrs=this.attributes(this, popen_attributes),
      ),
    open_description:
      (this, {popen_expr, popen_override, popen_attributes, popen_loc}) =>
      Opn.mk(
        map_loc(this, popen_expr),
        ~override=popen_override,
        ~loc=this.location(this, popen_loc),
        ~attrs=this.attributes(this, popen_attributes),
      ),
    include_description: (this, {pincl_mod, pincl_attributes, pincl_loc}) =>
      Incl.mk(
        this.module_type(this, pincl_mod),
        ~loc=this.location(this, pincl_loc),
        ~attrs=this.attributes(this, pincl_attributes),
      ),
    include_declaration: (this, {pincl_mod, pincl_attributes, pincl_loc}) =>
      Incl.mk(
        this.module_expr(this, pincl_mod),
        ~loc=this.location(this, pincl_loc),
        ~attrs=this.attributes(this, pincl_attributes),
      ),
    value_binding: (this, {pvb_pat, pvb_expr, pvb_attributes, pvb_loc}) =>
      Vb.mk(
        this.pat(this, pvb_pat),
        this.expr(this, pvb_expr),
        ~loc=this.location(this, pvb_loc),
        ~attrs=this.attributes(this, pvb_attributes),
      ),
    constructor_declaration:
      (this, {pcd_name, pcd_args, pcd_res, pcd_loc, pcd_attributes}) =>
      Type.constructor(
        map_loc(this, pcd_name),
        ~args=T.map_constructor_arguments(this, pcd_args),
        ~res=?map_opt(this.typ(this), pcd_res),
        ~loc=this.location(this, pcd_loc),
        ~attrs=this.attributes(this, pcd_attributes),
      ),
    label_declaration:
      (this, {pld_name, pld_type, pld_loc, pld_mutable, pld_attributes}) =>
      Type.field(
        map_loc(this, pld_name),
        this.typ(this, pld_type),
        ~mut=pld_mutable,
        ~loc=this.location(this, pld_loc),
        ~attrs=this.attributes(this, pld_attributes),
      ),
    cases: (this, l) => List.map(this.case(this), l),
    case: (this, {pc_lhs, pc_guard, pc_rhs}) => {
      pc_lhs: this.pat(this, pc_lhs),
      pc_guard: map_opt(this.expr(this), pc_guard),
      pc_rhs: this.expr(this, pc_rhs),
    },
    location: (_this, l) => l,
    extension: (this, (s, e)) => (
      map_loc(this, s),
      this.payload(this, e),
    ),
    attribute: (this, a) => {
      attr_name: map_loc(this, a.attr_name),
      attr_payload: this.payload(this, a.attr_payload),
      attr_loc: this.location(this, a.attr_loc),
    },
    attributes: (this, l) => List.map(this.attribute(this), l),
    payload: this =>
      fun
      | PStr(x) => PStr(this.structure(this, x))
      | PSig(x) => PSig(this.signature(this, x))
      | PTyp(x) => PTyp(this.typ(this, x))
      | [@implicit_arity] PPat(x, g) =>
        [@implicit_arity]
        PPat(this.pat(this, x), map_opt(this.expr(this), g)),
  };

  let extension_of_error = (error: Locations.location_error): extension =>
    Locations.extension_of_error(
      ~mk_pstr=x => PStr(x),
      ~mk_extension=x => Str.extension(x),
      ~mk_string_constant=
        x =>
          Str.eval(Exp.constant([@implicit_arity] Pconst_string(x, None))),
      error,
    );

  let attribute_of_warning = (loc, s) =>
    Attr.mk(
      {loc, txt: "ocaml.ppwarning"},
      PStr([
        Str.eval(
          ~loc,
          Exp.constant([@implicit_arity] Pconst_string(s, None)),
        ),
      ]),
    );

  include Locations.Helpers_impl;

  let cookies = ref(String.Map.empty);

  let get_cookie = k =>
    try(Some(String.Map.find(k, cookies^))) {
    | Not_found => None
    };

  let set_cookie = (k, v) => cookies := String.Map.add(k, v, cookies^);

  let tool_name_ref = ref("_none_");

  let tool_name = () => tool_name_ref^;

  module PpxContext = {
    open Longident;
    open Asttypes;
    open Ast_helper;

    let lid = name => {txt: Lident(name), loc: Location.none};

    let make_string = x =>
      Exp.constant([@implicit_arity] Pconst_string(x, None));

    let make_bool = x =>
      if (x) {
        Exp.construct(lid("true"), None);
      } else {
        Exp.construct(lid("false"), None);
      };

    let rec make_list = (f, lst) =>
      switch (lst) {
      | [x, ...rest] =>
        Exp.construct(
          lid("::"),
          Some(Exp.tuple([f(x), make_list(f, rest)])),
        )
      | [] => Exp.construct(lid("[]"), None)
      };

    let make_pair = (f1, f2, (x1, x2)) => Exp.tuple([f1(x1), f2(x2)]);

    let make_option = (f, opt) =>
      switch (opt) {
      | Some(x) => Exp.construct(lid("Some"), Some(f(x)))
      | None => Exp.construct(lid("None"), None)
      };

    let get_cookies = () => (
      lid("cookies"),
      make_list(
        make_pair(make_string, x => x),
        String.Map.bindings(cookies^),
      ),
    );

    let mk = fields => {
      attr_name: {
        txt: "ocaml.ppx.context",
        loc: Location.none,
      },
      attr_payload: Parsetree.PStr([Str.eval(Exp.record(fields, None))]),
      attr_loc: Location.none,
    };

    let make = (~tool_name, ()) => {
      let fields = [
        (lid("tool_name"), make_string(tool_name)),
        (
          lid("include_dirs"),
          make_list(make_string, Clflags.include_dirs^),
        ),
        (
          lid("load_path"),
          make_list(
            make_string,
            Migrate_parsetree_compiler_functions.get_load_paths(),
          ),
        ),
        (
          lid("open_modules"),
          make_list(make_string, Clflags.open_modules^),
        ),
        (
          lid("for_package"),
          make_option(make_string, Clflags.for_package^),
        ),
        (lid("debug"), make_bool(Clflags.debug^)),
        (lid("use_threads"), make_bool(Clflags.use_threads^)),
        (lid("use_vmthreads"), make_bool(false)),
        (lid("recursive_types"), make_bool(Clflags.recursive_types^)),
        (lid("principal"), make_bool(Clflags.principal^)),
        (
          lid("transparent_modules"),
          make_bool(Clflags.transparent_modules^),
        ),
        (
          lid("unboxed_types"),
          make_bool(Migrate_parsetree_compiler_functions.get_unboxed_types()),
        ),
        (lid("unsafe_string"), make_bool(Clflags.unsafe_string^)),
        get_cookies(),
      ];

      mk(fields);
    };

    let get_fields =
      fun
      | PStr([
          {
            pstr_desc:
              [@implicit_arity]
              Pstr_eval(
                {pexp_desc: [@implicit_arity] Pexp_record(fields, None)},
                [],
              ),
          },
        ]) => fields
      | _ =>
        raise_errorf("Internal error: invalid [@@@ocaml.ppx.context] syntax");

    let restore = fields => {
      let field = (name, payload) => {
        let rec get_string =
          fun
          | {
              pexp_desc:
                Pexp_constant([@implicit_arity] Pconst_string(str, None)),
            } => str
          | _ =>
            raise_errorf(
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] string syntax",
              name,
            )
        and get_bool = pexp =>
          switch (pexp) {
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct({txt: Longident.Lident("true")}, None),
            } =>
            true
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct({txt: Longident.Lident("false")}, None),
            } =>
            false
          | _ =>
            raise_errorf(
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] bool syntax",
              name,
            )
          }
        and get_list = elem =>
          fun
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct(
                  {txt: Longident.Lident("::")},
                  Some({pexp_desc: Pexp_tuple([exp, rest])}),
                ),
            } => [
              elem(exp),
              ...get_list(elem, rest),
            ]
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct({txt: Longident.Lident("[]")}, None),
            } =>
            []
          | _ =>
            raise_errorf(
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] list syntax",
              name,
            )
        and get_pair = (f1, f2) =>
          fun
          | {pexp_desc: Pexp_tuple([e1, e2])} => (f1(e1), f2(e2))
          | _ =>
            raise_errorf(
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] pair syntax",
              name,
            )
        and get_option = elem =>
          fun
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct({txt: Longident.Lident("Some")}, Some(exp)),
            } =>
            Some(elem(exp))
          | {
              pexp_desc:
                [@implicit_arity]
                Pexp_construct({txt: Longident.Lident("None")}, None),
            } =>
            None
          | _ =>
            raise_errorf(
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] option syntax",
              name,
            );

        switch (name) {
        | "tool_name" => tool_name_ref := get_string(payload)
        | "include_dirs" =>
          Clflags.include_dirs := get_list(get_string, payload)
        | "load_path" =>
          Migrate_parsetree_compiler_functions.load_path_init(
            get_list(get_string, payload),
          )
        | "open_modules" =>
          Clflags.open_modules := get_list(get_string, payload)
        | "for_package" =>
          Clflags.for_package := get_option(get_string, payload)
        | "debug" => Clflags.debug := get_bool(payload)
        | "use_threads" => Clflags.use_threads := get_bool(payload)
        | "use_vmthreads" =>
          if (get_bool(payload)) {
            raise_errorf(
              "Internal error: vmthreads not supported after 4.09.0",
            );
          }
        | "recursive_types" => Clflags.recursive_types := get_bool(payload)
        | "principal" => Clflags.principal := get_bool(payload)
        | "transparent_modules" =>
          Clflags.transparent_modules := get_bool(payload)
        | "unboxed_types" =>
          Migrate_parsetree_compiler_functions.set_unboxed_types(
            get_bool(payload),
          )
        | "unsafe_string" => Clflags.unsafe_string := get_bool(payload)
        | "cookies" =>
          let l = get_list(get_pair(get_string, x => x), payload);
          cookies :=
            List.fold_left(
              (s, (k, v)) => String.Map.add(k, v, s),
              String.Map.empty,
              l,
            );
        | _ => ()
        };
      };

      List.iter(
        fun
        | ({txt: Lident(name)}, x) => field(name, x)
        | _ => (),
        fields,
      );
    };

    let update_cookies = fields => {
      let fields =
        List.filter(
          fun
          | ({txt: Lident("cookies")}, _) => false
          | _ => true,
          fields,
        );

      fields @ [get_cookies()];
    };
  };

  let ppx_context = PpxContext.make;

  let extension_of_exn = exn =>
    extension_of_error(Locations.location_error_of_exn(exn));

  let apply_lazy = (~source, ~target, mapper) => {
    let implem = ast => {
      let (fields, ast) =
        switch (ast) {
        | [
            {
              pstr_desc:
                Pstr_attribute({
                  attr_name: {txt: "ocaml.ppx.context"},
                  attr_payload: x,
                }),
            },
            ...l,
          ] => (
            PpxContext.get_fields(x),
            l,
          )
        | _ => ([], ast)
        };

      PpxContext.restore(fields);
      let ast =
        try({
          let mapper = mapper();
          mapper.structure(mapper, ast);
        }) {
        | exn => [
            {
              pstr_desc:
                [@implicit_arity] Pstr_extension(extension_of_exn(exn), []),
              pstr_loc: Location.none,
            },
          ]
        };

      let fields = PpxContext.update_cookies(fields);
      [Str.attribute(PpxContext.mk(fields)), ...ast];
    };

    let iface = ast => {
      let (fields, ast) =
        switch (ast) {
        | [
            {
              psig_desc:
                Psig_attribute({
                  attr_name: {txt: "ocaml.ppx.context"},
                  attr_payload: x,
                  attr_loc: _,
                }),
            },
            ...l,
          ] => (
            PpxContext.get_fields(x),
            l,
          )
        | _ => ([], ast)
        };

      PpxContext.restore(fields);
      let ast =
        try({
          let mapper = mapper();
          mapper.signature(mapper, ast);
        }) {
        | exn => [
            {
              psig_desc:
                [@implicit_arity] Psig_extension(extension_of_exn(exn), []),
              psig_loc: Location.none,
            },
          ]
        };

      let fields = PpxContext.update_cookies(fields);
      [Sig.attribute(PpxContext.mk(fields)), ...ast];
    };

    let ic = open_in_bin(source);
    let magic =
      really_input_string(ic, String.length(Config.ast_impl_magic_number));

    let rewrite = transform => {
      Location.input_name := input_value(ic);
      let ast = input_value(ic);
      close_in(ic);
      let ast = transform(ast);
      let oc = open_out_bin(target);
      output_string(oc, magic);
      output_value(oc, Location.input_name^);
      output_value(oc, ast);
      close_out(oc);
    }
    and fail = () => {
      close_in(ic);
      failwith("Ast_mapper: OCaml version mismatch or malformed input");
    };

    if (magic == Config.ast_impl_magic_number) {
      rewrite(implem: structure => structure);
    } else if (magic == Config.ast_intf_magic_number) {
      rewrite(iface: signature => signature);
    } else {
      fail();
    };
  };

  let drop_ppx_context_str = (~restore) =>
    fun
    | [
        {
          pstr_desc:
            Pstr_attribute({
              attr_name: {Location.txt: "ocaml.ppx.context"},
              attr_payload: a,
              attr_loc: _,
            }),
        },
        ...items,
      ] => {
        if (restore) {
          PpxContext.restore(PpxContext.get_fields(a));
        };
        items;
      }
    | items => items;

  let drop_ppx_context_sig = (~restore) =>
    fun
    | [
        {
          psig_desc:
            Psig_attribute({
              attr_name: {Location.txt: "ocaml.ppx.context"},
              attr_payload: a,
              attr_loc: _,
            }),
        },
        ...items,
      ] => {
        if (restore) {
          PpxContext.restore(PpxContext.get_fields(a));
        };
        items;
      }
    | items => items;

  let add_ppx_context_str = (~tool_name, ast) => [
    Ast_helper.Str.attribute(ppx_context(~tool_name, ())),
    ...ast,
  ];

  let add_ppx_context_sig = (~tool_name, ast) => [
    Ast_helper.Sig.attribute(ppx_context(~tool_name, ())),
    ...ast,
  ];

  let apply = (~source, ~target, mapper) =>
    apply_lazy(~source, ~target, () => mapper);

  let run_main = mapper =>
    try({
      let a = Sys.argv;
      let n = Array.length(a);
      if (n > 2) {
        let mapper = () =>
          try(mapper(Array.to_list(Array.sub(a, 1, n - 3)))) {
          | exn =>
            /* PR#6463 */
            let f = (_, _) => raise(exn);
            {...default_mapper, structure: f, signature: f};
          };

        apply_lazy(~source=a[n - 2], ~target=a[n - 1], mapper);
      } else {
        Printf.eprintf(
          "Usage: %s [extra_args] <infile> <outfile>\n%!",
          Sys.executable_name,
        );
        exit(2);
      };
    }) {
    | exn =>
      prerr_endline(Printexc.to_string(exn));
      exit(2);
    };

  let register_function = ref((_name, f) => run_main(f));
  let register = (name, f) => register_function^(name, f);
};

module Type_immediacy = {
  type t /*IF_CURRENT = Type_immediacy.t */ =
    | Unknown
    | Always
    | Always_on_64bits;
};

module Outcometree = {
  /* Module [Outcometree]: results displayed by the toplevel */

  /* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
     [Toploop.print_out_value]
     [Toploop.print_out_type]
     [Toploop.print_out_sig_item]
     [Toploop.print_out_phrase] */

  /** An [out_name] is a string representation of an identifier which can be
      rewritten on the fly to avoid name collisions */

  type out_name /*IF_CURRENT = Outcometree.out_name */ = {
    mutable printed_name: string,
  };

  type out_ident /*IF_CURRENT = Outcometree.out_ident */ =
    | Oide_apply(out_ident, out_ident)
    | Oide_dot(out_ident, string)
    | Oide_ident(out_name);

  type out_string /*IF_CURRENT = Outcometree.out_string */ =
    | Ostr_string
    | Ostr_bytes;

  type out_attribute /*IF_CURRENT = Outcometree.out_attribute */ = {
    oattr_name: string,
  };

  type out_value /*IF_CURRENT = Outcometree.out_value */ =
    | Oval_array(list(out_value))
    | Oval_char(char)
    | Oval_constr(out_ident, list(out_value))
    | Oval_ellipsis
    | Oval_float(float)
    | Oval_int(int)
    | Oval_int32(int32)
    | Oval_int64(int64)
    | Oval_nativeint(nativeint)
    | Oval_list(list(out_value))
    | Oval_printer(Format.formatter => unit)
    | Oval_record(list((out_ident, out_value)))
    | Oval_string(string, int, out_string) /* string, size-to-print, kind */
    | Oval_stuff(string)
    | Oval_tuple(list(out_value))
    | Oval_variant(string, option(out_value));

  type out_type /*IF_CURRENT = Outcometree.out_type */ =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias(out_type, string)
    | Otyp_arrow(string, out_type, out_type)
    | Otyp_class(bool, out_ident, list(out_type))
    | Otyp_constr(out_ident, list(out_type))
    | Otyp_manifest(out_type, out_type)
    | Otyp_object(list((string, out_type)), option(bool))
    | Otyp_record(list((string, bool, out_type)))
    | Otyp_stuff(string)
    | Otyp_sum(list((string, list(out_type), option(out_type))))
    | Otyp_tuple(list(out_type))
    | Otyp_var(bool, string)
    | Otyp_variant(bool, out_variant, bool, option(list(string)))
    | Otyp_poly(list(string), out_type)
    | Otyp_module(out_ident, list(string), list(out_type))
    | Otyp_attribute(out_type, out_attribute)
  and out_variant /*IF_CURRENT = Outcometree.out_variant */ =
    | Ovar_fields(list((string, bool, list(out_type))))
    | Ovar_typ(out_type);

  type out_class_type /*IF_CURRENT = Outcometree.out_class_type */ =
    | Octy_constr(out_ident, list(out_type))
    | Octy_arrow(string, out_type, out_class_type)
    | Octy_signature(option(out_type), list(out_class_sig_item))
  and out_class_sig_item /*IF_CURRENT = Outcometree.out_class_sig_item */ =
    | Ocsg_constraint(out_type, out_type)
    | Ocsg_method(string, bool, bool, out_type)
    | Ocsg_value(string, bool, bool, out_type);

  type out_module_type /*IF_CURRENT = Outcometree.out_module_type */ =
    | Omty_abstract
    | Omty_functor(
        option((option(string), out_module_type)),
        out_module_type,
      )
    | Omty_ident(out_ident)
    | Omty_signature(list(out_sig_item))
    | Omty_alias(out_ident)
  and out_sig_item /*IF_CURRENT = Outcometree.out_sig_item */ =
    | Osig_class(
        bool,
        string,
        list((string, (bool, bool))),
        out_class_type,
        out_rec_status,
      )
    | Osig_class_type(
        bool,
        string,
        list((string, (bool, bool))),
        out_class_type,
        out_rec_status,
      )
    | Osig_typext(out_extension_constructor, out_ext_status)
    | Osig_modtype(string, out_module_type)
    | Osig_module(string, out_module_type, out_rec_status)
    | Osig_type(out_type_decl, out_rec_status)
    | Osig_value(out_val_decl)
    | Osig_ellipsis
  and out_type_decl /*IF_CURRENT = Outcometree.out_type_decl */ = {
    otype_name: string,
    otype_params: list((string, (bool, bool))),
    otype_type: out_type,
    otype_private: Asttypes.private_flag,
    otype_immediate: Type_immediacy.t,
    otype_unboxed: bool,
    otype_cstrs: list((out_type, out_type)),
  }
  and out_extension_constructor /*IF_CURRENT = Outcometree.out_extension_constructor */ = {
    oext_name: string,
    oext_type_name: string,
    oext_type_params: list(string),
    oext_args: list(out_type),
    oext_ret_type: option(out_type),
    oext_private: Asttypes.private_flag,
  }
  and out_type_extension /*IF_CURRENT = Outcometree.out_type_extension */ = {
    otyext_name: string,
    otyext_params: list(string),
    otyext_constructors: list((string, list(out_type), option(out_type))),
    otyext_private: Asttypes.private_flag,
  }
  and out_val_decl /*IF_CURRENT = Outcometree.out_val_decl */ = {
    oval_name: string,
    oval_type: out_type,
    oval_prims: list(string),
    oval_attributes: list(out_attribute),
  }
  and out_rec_status /*IF_CURRENT = Outcometree.out_rec_status */ =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status /*IF_CURRENT = Outcometree.out_ext_status */ =
    | Oext_first
    | Oext_next
    | Oext_exception;

  type out_phrase /*IF_CURRENT = Outcometree.out_phrase */ =
    | Ophr_eval(out_value, out_type)
    | Ophr_signature(list((out_sig_item, option(out_value))))
    | Ophr_exception((exn, out_value));
};

module Config = {
  let ast_impl_magic_number = "Caml1999M027";
  let ast_intf_magic_number = "Caml1999N027";
};

let map_signature = mapper => mapper.Ast_mapper.signature(mapper);
let map_structure = mapper => mapper.Ast_mapper.structure(mapper);

let shallow_identity = {
  let id = (_, x) => x;
  {
    Ast_mapper.structure: id,
    structure_item: id,
    module_expr: id,
    signature: id,
    signature_item: id,
    module_type: id,
    with_constraint: id,
    class_declaration: id,
    class_expr: id,
    class_field: id,
    class_structure: id,
    class_type: id,
    class_type_field: id,
    class_signature: id,
    class_type_declaration: id,
    class_description: id,
    type_declaration: id,
    type_kind: id,
    typ: id,
    type_extension: id,
    extension_constructor: id,
    value_description: id,
    pat: id,
    expr: id,
    module_declaration: id,
    module_type_declaration: id,
    module_binding: id,
    open_description: id,
    include_description: id,
    include_declaration: id,
    value_binding: id,
    constructor_declaration: id,
    label_declaration: id,
    cases: id,
    case: id,
    location: id,
    extension: id,
    attribute: id,
    attributes: id,
    payload: id,
    binding_op: id,
    module_substitution: id,
    open_declaration: id,
    type_exception: id,
  };
};

let failing_mapper = {
  let fail = (_, _) =>
    invalid_arg(
      "failing_mapper: this mapper function should never get called",
    );

  {
    Ast_mapper.structure: fail,
    structure_item: fail,
    module_expr: fail,
    signature: fail,
    signature_item: fail,
    module_type: fail,
    with_constraint: fail,
    class_declaration: fail,
    class_expr: fail,
    class_field: fail,
    class_structure: fail,
    class_type: fail,
    class_type_field: fail,
    class_signature: fail,
    class_type_declaration: fail,
    class_description: fail,
    type_declaration: fail,
    type_kind: fail,
    typ: fail,
    type_extension: fail,
    extension_constructor: fail,
    value_description: fail,
    pat: fail,
    expr: fail,
    module_declaration: fail,
    module_type_declaration: fail,
    module_binding: fail,
    open_description: fail,
    include_description: fail,
    include_declaration: fail,
    value_binding: fail,
    constructor_declaration: fail,
    label_declaration: fail,
    cases: fail,
    case: fail,
    location: fail,
    extension: fail,
    attribute: fail,
    attributes: fail,
    payload: fail,
    binding_op: fail,
    module_substitution: fail,
    open_declaration: fail,
    type_exception: fail,
  };
};

let make_top_mapper = (~signature, ~structure) => {
  ...failing_mapper,
  Ast_mapper.signature: (_, x) => signature(x),
  structure: (_, x) => structure(x),
};
